{"componentChunkName":"component---src-pages-index-tsx","path":"/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"이전 글(리액트 쿼리, 늦게 시작했지만 더 확실한 서버 상태 관리)에 이어 리액트 쿼리 구조와 동작 원리를 분석해 보았다. useQuery()를 시작으로 QueryClient까지 핵심 객체들의 역할을 파악하고, 이들 간의 협업 구조를 이해하면 라이브러리를 사용할 때 훨씬 유리할 것이다. query-core와 react-core 초반에는 React Quer…","frontmatter":{"slug":"/2025/05/11/how-react-query-works","date":"2025-05-11T00:00:00.000Z","title":"리액트 쿼리, 내부는 이렇게 움직인다"}},{"excerpt":"마침내 리액트 쿼리(React Query)를 사용했다. '서버 상태를 따로 관리하자', '최신 기술 스택으로 바꾸자'는 이야기가 팀에서 꾸준히 나왔지만, 나는 매번 보수적인 태도를 유지해 왔다. 제품이 잘 돌아가고 있는데 굳이 바꿀 필요가 있을까 하는 생각과, 신기술을 학습해야 한다는 부담감이 한 켠에 있었기 때문이다. 팀원들은 포기하지 않고 리액트 쿼리…","frontmatter":{"slug":"/2025/04/26/react-query","date":"2025-04-26T00:00:00.000Z","title":"리액트 쿼리(TanStack Query), 늦게 시작했지만 더 확실한 서버 상태 관리"}},{"excerpt":"코드 리뷰를 시작하지 일 년이 지났다. 그 전에는 혼자 일하다 보니 다른 사람의 코드를 읽을 일이 없었고, 팀원이 몇 명 있긴 했지만 모두 다른 직군이었다. 재작년부터는 프론트엔드 개발자 여섯 분과 함께 일하면서 비로소 코드 리뷰할 기회가 생겼다. 사실 리뷰에 크게 신경 쓰지 않았다. 지금까지는 별다른 어려움 없이 작업해왔기에 코드 리뷰의 중요성을 실감하…","frontmatter":{"slug":"/2025/01/20/code-review","date":"2025-01-20T00:00:00.000Z","title":"코드 리뷰: 협업으로 배우고 성장하기"}},{"excerpt":"import 함수는 실행 환경에 따라 전달받은 인자를 해석하여 해당 자원을 불러온다. 예를 들어 Node.js 환경에서는 파일을, 브라우져 환경에서는 HTTP 요청을 통해 자원을 로드한다. 이 특성을 이용하면 애플리케이션 초기 로딩 속도를 개선할 수 있겠다. 초기에는 최소한의 코드만 로드하고, 필요할 때 나머지 코드를 지연 로딩할 수 있기 때문이다. 이 …","frontmatter":{"slug":"/2025/01/07/module-federation","date":"2025-01-07T00:00:00.000Z","title":"모듈 페더레이션 구조와 동작 원리"}},{"excerpt":"웹 애플리케이션의 초기 로딩 속도를 개선하는 핵심 전략 중 하나는 필요한 코드만을 적절한 시점에 로드하는 것이다. Reac.lazy는 이러한 코드 분할(Code Spliiting)을 효과적으로 구현할 수 있게\n도와주는 도구다. 이 글에서는 React.lazy의 동작 원리와 사용 방법을 살펴 보겠다. 동적 import의 이해 모듈을 동적으로 불러오는 imp…","frontmatter":{"slug":"/2024/12/18/react-lazy","date":"2024-12-18T00:00:00.000Z","title":"리액트 lazy"}},{"excerpt":"타입 힌트로 더 안전하게 이번 새로운 모듈 페더레이션은 타입 힌트 제공이라는 편의를 제공한다. 원격 모듈을 사용하는 애플리케이션을 흔히 호스트(또는 소비자)라고 부른다. 만약 호스트를 타입스크립트로 개발한다면, 원격 모듈의 타입 정보를 제공받는 것은 큰 장점이 된다. 이번 모듈 페더레이션은 원격 모듈과 호스트 간에 타입 정보를 동기화하여, 더 안전하고 예…","frontmatter":{"slug":"/2024/12/08/module-federation-logging","date":"2024-12-08T00:00:00.000Z","title":"모듈 페더레이션 타입 힌트와 로깅"}},{"excerpt":"6편 소개 브라우져가 웹 페이지를 렌더링할 때 발생하는 HTTP 요청을 효율적으로 제어하는 다양한 기법 16장. 렌더링 최적화: 외부 리소스의 로드 시점을 제어해 웹 성능을 최적화하는 기술 17장. 캐시: 서버와 브라우저가 HTTP 헤더를 통해 캐싱 정책을 주고받아 성능을 최적화하는 메커니즘 16장. 로딩 최적화 16.1 렌더링 과정 DSN 질의 HTML…","frontmatter":{"slug":"/2024/07/12/lecture-http-part6","date":"2024-07-12T00:01:00.000Z","title":"[HTTP] 6편. 성능"}},{"excerpt":"5편 소개 브라우져 보안과 함께 HTTP 통신을 더 안전하게 만드는 TLS 13장. 브라우져 보안: XSS(크로스 사이트 스크립팅)와 같은 공격 기법과 이를 방지하기 위한 브라우저 보안 정책 14장. CORS: 외부 도메인의 자원을 안전하게 활용하기 위한 CORS 정책과 적용 방법 15장. HTTPS: HTTPS가 네트워크 보안을 강화하는 방식과 TLS의…","frontmatter":{"slug":"/2024/07/11/lecture-http-part5","date":"2024-07-11T00:01:00.000Z","title":"[HTTP] 5편. 보안"}},{"excerpt":"4편 소개 HTTP의 비연결성을 극복하는 다양한 기술 9장. 폴링: 클라이언트가 주기적으로 서버에 요청을 보내서 새로운 데이터를 확인하는 방법 10장. 롱 폴링: 폴링 보다 호율적인 통신 기법 11장. SSE: 서버가 클라이언트로 실시간 데이터를 푸시하는 방법 12장. 웹 소켓: 클라이언트와 서버 간의 양방향 통신 프로토콜 9장. 폴링 9.1 구조 지속적…","frontmatter":{"slug":"/2024/07/10/lecture-http-part4","date":"2024-07-10T00:01:00.000Z","title":"[HTTP] 4편. 추가 프로토콜"}},{"excerpt":"3편 소개 직접 만들 수 있는 HTTP 요청 6장. AJAX 요청과 응답: fetch 함수로 AJAX 요청과 응답을 다루는 법에 대해 7장. AJAX 진행율과 취소: AJAX 진행율을 계산하는 방법과 요청을 취소하는 방법에 대해 8장. AJAX 라이브러리: fetch와 XHR 객체 기반의 주요 AJAX 라이브러리 6장. 업로드와 응답 6.1 AJAX Fr…","frontmatter":{"slug":"/2024/07/09/lecture-http-part3","date":"2024-07-09T00:01:00.000Z","title":"[HTTP] 3편. AJAX"}}]}},"pageContext":{}},"staticQueryHashes":["2263867198"]}