# 2장. UI컴포넌트 1: 메뉴목록 화면

첫번째 화면인 메뉴 목록 화면을 만들어 볼 것이다. 1부에서 학습한 지식만을 가지고 만들 것이다.
1부와 마찬가지로 요구사항 문서를 보면서 하나씩 해결해 가는 방식으로 진행하겠다.

## 단일 컴포넌트: MenuPage

이 화면이다.
// todo ![메뉴 목록]()

요구사항

- 헤더. 화면 제목 "메뉴목록"
- 요구사항: 본문: 상품 목록
- 요구사항: 푸터: 네비게이션바 "메뉴목록", "주문내역"

1부와 마찬가지로 스타일 정의를 CSS 코드로 미리 만들어 놓았다. index.html에서 로딩하는
main.css 파일이다.

```css
.Page {
  display: flex:
  flex-direction: column;
  min-width: 320px;
}
/* 생략 */
```

미리 정의한 css 클래스를 적절히 사용해서 화면을 만들 것이다. 먼저 전체 레이아웃을 잡아주는 Page
클래스를 사용하겠다.

```jsx
<div className="Page">
  {/* 헤더 */}
  <header>
    <h1>메뉴목록</h1>
  </header>

  {/* 본문 */}
  <main>여기에 메인 컨텐츠를 담는다.</main>

  {/* 푸터 */}
  <footer>
    <nav className="Navbar">
      <a className="active" href="#">
        메뉴목록
      </a>
      <a href="#">주문내역</a>
    </nav>
  </footer>
</div>
```

Page 클래스를 사용한 div를 최상단 엘리먼트로 감싸고 그 안에 header, main, footer 엘리먼트를
사용하면 전체 문서 윤곽을 그릴 수 있다.

// todo ![.Page 클래스를 사용해 전체 문서 윤곽을 그린다.]()

메인 부분을 더 만들어 보자. 상품 목록을 그릴 것이다.

```jsx
<main>
  <div class="MenuPage">
    <ul>
      <li>
        <div className="MenuItem">
          <div class="description">
            <h2>고소한 바질 파스타</h2>
            <div>6,000원</div>
            <button className="Button brand">주문하기</button>
          </div>
          <div className="thumbnail">
            <img
              src="./images/menu-고소한바질파스타.jpg"
              alt="고소한바질파스타 6,000원"
            />
          </div>
        </div>
      </li>
    </ul>
  </div>
</main>
```

MenuPage, MenuItem이란 CSS 클래스를 사용해 메뉴 화면의 메뉴 목록을 그렸다. 메뉴 이름과 가격,
그리고 주문할 수 있는 주문 버튼이 위치한다. 그리고 옆에는 메뉴 썸네일 이미지가 위치할 것이다.

// todo ![MenuPage, MenuItem 클래스를 이용해 메뉴 목록을 그렸다.]()

// todo menuapi 연동하기

## 리액트로 생각하기

여기서 잠시 1부의 마지막 내용을 떠올려 보자.

// todo [1부) 작은 컴포넌트로 나누기]()

리액트로 사고하는 방법을 다루었다. 방금 만든 App 컴포넌트처럼 거대한 단일 컴포넌트를 여러 개의 작은
것으로 분리하는 방법을 다루었다.

이러한 과정을 거치면 코드를 유지하는데 상당한 이점이 있다. 단일 책임 혹은 비교적 적은 책임만지기
때문에 컴포넌트가 단순해 진다. 하는 일이 명확하기 때문에 코드가 쉽게 읽힐 것이다. 어떤 컴포넌트는
재사용할 수도 있다. 처음엔 코딩양이 많은것 같지만 컴포넌트 설계를 잘 거치면 전체 코드는 줄어들 것이다.

리액트 문서에는 이것을 [React로 사고하기]()라는 장에서 설명한다. 자세히 살펴보자.

1. UI를 컴포넌트 계층 구조로 나누기
2. 리액트로 정적인 버전 만들기
3. UI 상태(state)에 대한 최소한의 (하지만 완전한) 표현 찾아내기
4. 상태가 어디에 있어야 할 지 찾기
5. 역방향 데이터 흐름 추가하기

디자인을 보고 이러한 흐름으로 컴포넌트를 설계하는 방법이 초심자에게는 결코 쉬운 일은 아니다.
리액트를 사용하면서 느꼈던 것은 오히려 반대였다. 먼저 전체를 UI를 만들고 그것을 다시 컴포넌트로
쪼게는 것이 체감상 쉬웠다. 그래서 이전 장에서 디자인을 보고 하나의 컴포넌트만 사용해서 빠르게
만들어 본 것이다.

다음 장 부터는 이 App 컴포넌트를 리액트로 사고하기 방식으로 접근해 다시 설계해서 하나씩 분리해
볼 것이다.

## 버튼 컴포넌트: Button

디부터 손을 대야할까? 가만히 보니 버튼이 좀 만만해 보인다. 작기도 하고 다른 화면에서도 여러번 사용하기
때문이다. 물론 모양이 좀 다르긴 하다. 어찌되었든 이 녀석부터 뜯어 내어 보자.

src/components 폴더를 만들고 이 안에 Button.jsx 파일을 만들자. 여기에 App 컴포넌트에 있는
버튼 코드를 그대로 옮긴다.

```jsx
// src/components/Button.jsx
const Button = () => <button className="Button brand">주문하기</button>

export default Button
```

App 에서는 코드 한 줄로 주문하기 버튼을 그릴 수 있다.

```jsx
<Button />
```

우리는 버튼은 다른 곳에서도 사용할 것이다.

"주문하기"라는 버튼 문구가 바뀔 수도 있다. 다른 화면에는 "결재하기", "전화", "가게보기" 버튼도 있다.
그러면 버튼을 사용하는 측에서 문구를 정해야한다. Button이 외부에서 이 문구를 받아 처리하도록 변경하자.

```jsx
// children 속성으로 버튼의 문구를 받을 것이다.
const Button = ({ children }) => (
  <button className="Button brand">{children}</button>
)
```

이제는 Button 을 사용할 때 표시할 문구를 함께 전달해야한다.

```jsx
<Button>주문하기</Button>
```

각 화면에서는 필요에 따라 문구를 변경해서 재활용할 수 있다.

```jsx
<Button>결재하기</Button>
<Button>전화</Button>
<Button>가게보기</Button>
```

버튼을 사용한 디자인을 보면 색상과 크기도 다르다. 장바구니 화면에서는 크고 색상이 채워진 모양이고
주문하기에서는 색상이 빠진 모양이다. 이와 관련된 css 클래스는 다음과 같다.

```css
.brand // 색상 관련
.brand-solid // 색상 관련
.block // 크기 관련;
```

색상과 크기 두 가지를 조합해서 버튼을 만들수 있다. 우리의 Button 컴포넌트가 이러한 특성을 처리하도록
변경해야겠다. 이것을 버튼 안에서 정의할 수 없다. 버튼 안에 상세 내용을 구현(하드코딩)하는 순간 스타일은
더 이상 재활용할 수 없기 때문이다. 버튼 문구를 children 속성으로 받은 것처럼 색상과 크기도 외부에서
받아 처리하도록 하자.

```jsx
const Button = ({ styleType = "default", block = false, children }) => {
  // 기반 스타일
  let className = "Button"

  // 색상
  if (styleType !== "default") {
    className += ` ${styleType}`
  }

  // 크기
  if (block) {
    className += ` block`
  }

  return <button className={className}>{children}</button>
}
```

전달한 props 객체의 값에 따라서 button에 설정할 css 클래스 이름 문자열을 계산해서 전달할 것이다.

이 컴포넌트는 이제 용도에 따라 이렇게 사용할 수 있게 되었다.

```jsx
<Button />
<Button styleType="brand" />
<Button styleType="brand-solid" block />
```

메뉴 목록에서 사용할 버튼은 보통의 민트색이다.

```jsx
<Button styleType="brand">주문하기</Button>
```

Button 컴포넌트의 역할에 해 좀더 생각해 보자.

버튼은 유저가 클릭하는 것이다. 컴포넌트는 유저의 클릭을 처리해야하는 책임도 진다. 컴포넌트 자체가
button을 가지고 있기 때문에 onClick 속성으로 클릭 시점을 알 수 있기 때문이다.

```jsx
const handleClick = () => {
  /* 클릭 처리 */
}
// ...
return <button onClick={handleClick}>{children}</button>
```

handleClick은 어떤 일을 해야할까? 메뉴 목록 화면에서 버튼을 클릭하면 장바구니 화면으로 이동하는 것이
요구사항이다("주문하기" 버튼을 클릭하면 장바구니 화면으로 이동한다).

handleClick이 장바구니 이동 로직을 담으면 될까? 계속 물어보는 이유는 그렇지 않다는 걸 생각해 보라는
의도다.

handleClick이 장바구니 이동까지 담당한다면 컴포넌트의 이름은 GoToCartPageButton이어야 한다.
지금은 수식어가 없는 순수한 Button이다. 어떤 환경에서 사용되더라도 사용자 클릭을 처리할 수 있는
비교적 범용적인 녀석이어야 한다.

그럼 장바구니 이동 로직은 누구의 역할일까? 아직 정확히 누군지는 모르지만 Button을 사용하는 측이다.
외부에서 책임지게 하려면 외부에서 함수를 넘겨주어 버튼에게 적당한 타이밍에 콜백하라고 요청할 수 있다.
onClick 이라는 이름으로 콜백함수를 받고록 props 객체를 확장하겠다.

```jsx
const button = ({
  styleType = "default",
  block = false,
  onClick,
  children,
}) => {
  // ...
  return (
    <button className={className} onClick={onClick}>
      {children}
    </button>
  )
}
```

사용하는 쪽에서는 콜백함수를 넘겨줄 수 있다.

```jsx
<Button styleType="brand" onClick={() => console.log("click")}>
  주문하기
</Button>
```

onClick에 로그 찍는 함수를 넘겼다. Button 컴포넌트는 사용자가 버튼을 클릭할 때 이 함수를 실행할
것이다. 사용하는 쪽에서는 이 함수 본체가 실행될때 버튼이 클릭된 시점을 알 수 있을 것이다. 버튼의
역할은 딱 여기까지다. 넘겨받은 콜백함수를 적절한 타이밍에 호출하는 것.

props 객체가 커지면서 컴포넌트의 인자가 좀 복잡해졌다. 전개 연산자를 사용하면 훨씬 간결하다.

```jsx
const Button = ({ styleType = "default", block = false, ...props }) => {
  let className = "Button"

  if (styleType !== "default") {
    className += ` ${styleType}`
  }

  if (block) {
    className += ` block`
  }

  return <button {...props} className={className} />
}

export default Button
```

App에서 Button 컴포넌트를 분리했다.

```jsx
<App />
  <Button />
```

## 메뉴 컴포넌트: MenuItem

이번에는 버튼을 감싸고 있는 메뉴 UI를 담당할 컴포넌트를 만들어 보자. 메뉴 정보와 주문하기 버튼으로
구성되었는데 이를 MenuItem이란 이름의 컴포넌트로 분리할 것이다.

먼저는 App 에서 구현한 코드를 그대로 옮기자. src/components/MenuItem.jsx 파일을 만들어
이동하자.

```jsx
const MenuItem = () => <div className="MenuItem">{/* ... */}</div>
```

App 컴포넌트에서는 코드 한 줄로 메뉴 아이템을 그릴수 있게된다.

```jsx
// src/App.jsx
<MenuItem />
```

하지만 이것도 버튼처럼 고려해야할 부분이 있다. MenuItem을 재활용할 수 없다. 특정 메뉴 정보만 그리기
때문이다. 지금 상태로는 PastarMenuItem 컴포넌트라고 불러야 적당하다.

이러한 특정 메뉴 정보를 컴포넌트에서 걷어 내야한다. 그러면서도 특정 메뉴 정보를 화면에 그려야할 책임도
가지고 있다. 컴포넌트를 사용하는 쪽에서 어떤 메뉴인지를 정하고 이 정보를 컴포넌트에 전달하는 방식.
즉 버튼이 했던 방식과 같은 원리로 컴포넌트를 설계해야할 것이다. // 어떤 패턴인지, 역할인지,
소프트웨어 공학원칙인지 짚어주면 좋겠다.

MenuItem의 props가 메뉴 정보를 받도록 인터페이스를 열어주자. 이 어플리케이션은 api를 통해 메뉴
데이터를 가져올 것이다. 나중에 api 연동할 때 직접 사용할 것이다. 먼저 api를 통해 가져올 데이터
모양을 확인해 보자.

브라우져 개발자 도구를 열고 다음 명령어로 http 요청을 하나 만들어 보자.

```jsx
fetch("/api/menu/list")
```

fetch() 함수가 반환한 프라미스 객체 값이 로그에 찍힐 것이다. 그리고 네트워크 탭으로 이동하면 http
요청이 하나 생성된 것을 확인 할 수 있다. json 데이터가 응답되는데 안을 들여다보면 메뉴 목록인 것을
눈치챘을 것이다.

```
0: {name: "해물 계란 라면', price: 6000 ...}
1: {name: "햄 야채 토스트', price: 8000 ...}
...
```

리액트 컴포넌트를 만들 때는 처음부터 api 연동을 하지 않는다. 이 데이터 모양을 기준으로 목업 데이터를
만들고 이것을 먼저 컴포넌트에서 사용할 것이다. 메뉴 하나를 목업으로 만들자.

```jsx
// api 응답과 비슷한 메뉴 데이터
const menu = {
  id: "menu-id-001",
  name: "해물 계란 라면",
  price: "6000",
  thumbnail: "./images/menu-해물계란라면.jpg",
}
```

MenuItem은 외부에서 이 정보를 받아 UI를 그리게 될 것이다. props로 menu 객체를 받도록 하자.

```jsx
const MenuItem = ({ name, price, thumbnail }) => {
  return (
    <div className="MenuItem">
      <div className="description">
        <h2>{name}</h2>
        <div>{price.toLocaleString()}원</div>
        <Button styleType="brand" onClick={() => console.log("click")}>
          주문하기
        </Button>
      </div>
      <div className="thumbnail">
        <img src={thumbnail} alt={`${name} ${price.toLocaleString()}원`} />
      </div>
    </div>
  )
}
```

이렇게 만든 컴포넌트는 App 컴포넌트에서 이렇게 사용할 수 있다.

```jsx
<div class="MenuPage">
  <ul>
    <li>
      <MenuItem {...menu} />
    </li>
  </ul>
</div>
```

Button에 이어 MenuItem 컴포넌트도 분리해서 만들었다.

```jsx
<App />
  <MenuItem />
    <Button />
```

## (실습)타이틀 컴포넌트: Title

상단에 위치할 타이틀을 분리해 보자. 이 녀석은 모든 화면에서 재사용될 것이다.

src/components/Title.jsx 파일을 만들자. 그리고 App에 있는 타이틀 코드를 옮기자.

이것은 직접 실습해 보기 바란다. 다음 장에서 같이 풀어볼 것이다.

## (풀이)타이틀 컴포넌트: Title

```jsx
// src/components/Title.jsx
const Title = ({ children }) => <h1>{children}</h1>

export default Title

// src/App.jsx
;<Title>메뉴목록</Title>
```

## (실습)네비게이션바 컴포넌트: Navbar

하단에 위치할 네비게이션 바도 분리해 보자. 이 녀석은 주문내역 화면에서도 재사용 될 것이기 때문이다.

src/components/Navbar.jsx 파일을 만들자. 그리고 App에 있는 네비게이션바 코드를 옮기자.

이것은 직접 실습해 보기 바란다. 다음 장에서 실습을 같이 풀어볼 것이다.

전체 컴포넌트 구조는 다음과 같다.

```jsx
<App />
  <Title />
  <MenuItem />
    <Button />
```

## (풀이)네비게이션바 컴포넌트: Navbar

```jsx
// src/components/Navbar.jsx
const Navbar = () => (
  <nav className="Navbar">
    <a className="active" href="#">
      메뉴목록
    </a>
    <a href="#">주문내역</a>
  </nav>
)

export default Navbar

// src/App.jsx
;<Navbar />
```

실제 링크 동작은 이후에 소개할 라우터 장에서 구현할 것이다.

전체 컴포넌트 구조는 다음과 같다.

```jsx
<App />
  <Title />
  <MenuItem />
    <Button />
  <Navbar />
```

## 페이지 컴포넌트: Page

App 컴포넌트의 문서 구조를 다시 보자.

```jsx
const App = () => (
  <div className="Page">
    <header>
      <Title>메뉴목록</Title>
    </header>
    <main>
      <div class="MenuPage">
        <ul>
          <li>
            <MenuItem {...menu} />
          </li>
        </ul>
      </div>
    </main>
    <footer>
      <Navbar />
    </footer>
  </div>
)
```

MenuItem과 Button 그리고 Navbar 컴포넌트는 분리해 냈지만 그래도 부족하다. 처음에 Page
클래스로 윤곽을 그렸던 것을 기억해보자. 헤더, 메인, 푸터 순으로 그렸다. 이러한 화면 배치는
어플리케이션 전반에 녹아있다. 장바구니 화면, 주문내역 화면. 모두 자세한 모습은 다르지만 전체 윤곽은
세 가지로 되어 있다.

이러한 화면 윤곽도 각 화면에서 재활용할 수 없을까? 방법이 있다. 이 역할을 하는 컴포넌트를 만들고
관련된 코드를 옮기면된다. 쉽다. 지금까지 하던 패턴으로 만들면 된다. css 클래스 이름처럼 Layout
이란 이름의 컴포넌트를 만들자.

```jsx
// src/components/Page.jsx
const Page = () => (
  <div className="Page">
    <header>{}</header>
    <main>{}</main>
    <footer>{}</footer>
  </div>
)
```

Page 클래스로 감싸고 그 안에 header, main, footer 앨리먼트를 사용해 어플리케이션의 윤곽을 잡는다.
다만 각 엘리먼트에 뭐가 그려질지는 전혀 모른다. 만약 그것을 알고 컴포넌트 안에서 그린다면 XXXPage
컴포넌트가 될 것이다. 우리가 분리한 것은 순전히 페이지 UI만 그리는 것이다. 이름에 걸맞다.

그러면 각 섹션의 상세 UI는 어떻게 그릴까? 바로 사용하는 쪽의 책임으로 위임한다. 사용하는 쪽에서
그려서 Page 컴포넌트로 넘겨주면 된다. props 객체로 맞아서 처리하자.

```jsx
const Page = ({ header, children, footer }) => (
  <div className="Page">
    <header>{header}</header>
    <main>{children}</main>
    <footer>{footer}</footer>
  </div>
)
```

이 컴포넌트를 사용하는 쪽에는 어떻게 전달하던지 Page는 전체 윤곽을 위해 페이지를 구조화하는 것에만
집중한다. 이로서 헤더, 본문, 푸터를 배치하는 컴포넌트를 만들었다. App에서는 이렇게 사용할 수 있다.

```jsx
const App = () => (
  <Page header={<Title>메뉴목록</Title>} footer={<Navbar />}>
    <div class="MenuPage">
      <ul>
        <li>
          <MenuItem {...menu} />
        </li>
      </ul>
    </div>
  </Layout>
)
```

거대한 단일 컴포넌트가 점점 구조화되는 것 같다. 마지막 컴포넌트도 분리해 보자.

컴포넌트 모습은 다음과 같다.

```jsx
<App />
  <Page />
    <Title />
    <MenuItem />
      <Button />
    <Navbar />
```

## 메뉴페이지 컴포넌트: MenuPage

우리가 만든 App 컴포넌트에 대해 생각해보자. 어플리케이션 전체를 담당한다는 의미로 이름을 지었다.
하지만 이것은 메뉴 목록만 그리는 꼴이 되었다. 이것 뿐만아니라 장바구니 화면과 주문 내역 화면도
렌더링해서 비로소 App이란 이름에 걸맞는 컴포넌트가 될수 있다.

현재 만들고 있는 페이지 이름을 따서 MenuPage란 컴포넌트로 분리해 보자. 이전 컴포넌트들을
src/components 폴더에 만들었는데 이번에는 src/pages 폴더에 만들어 보겠다. 컴포넌트이긴하지만
페이지를 담당하는 컴포넌트라서 다른 계층이라고 생각하기 때문이다.

```jsx
// src/pages/MenuPage.jsx
const MenuPage = () => (
  <Page header={<Title>메뉴목록</Title>} footer={<Navbar />}>
    <div class="MenuPage">
      <ul>
        <li>
          <MenuItem {...menu} />
        </li>
      </ul>
    </div>
  </Page>
)

export default MenuPage
```

App 컴포넌트의 대부분의 코드를 옮겼다.

이제 App은 이렇게 변할 것이다.

```jsx
// src/App.jsx
const App = () => <MenuPage />
```

단순히 MenuPage만 사용했다. 앞으로 페이지를 추가할 때마다 App 컴포넌트에서 사용할 것이다.

전체 컴포넌트 트리는 다음과 같다.

```jsx
<App />
  <MenuPage />
    <Page />
      <Title />
      <MenuItem />
        <Button />
      <Navbar />
```

## 중간정리

App 컴포넌트 하나로 메뉴 목록 화면을 만들었다.

리액트로 생각하기 5단계로 컴포넌트를 다시 설계했다. 작은 컴포넌트로 분리했다.

Button 지금 역할은 작지만 점점 확장해 나갈 것이다.

MenuItem 메뉴 하나를 렌더하는 역할. 리스트 렌더링으로 전체 목록을 그린다.

Title 타이틀을 위한 컴포넌트. 하단에 위치한다. 헤더 역할

Navbar 네비게이션을 위한 컴포넌트. 하단 고정 스타일을 분리했다. 푸터의 역할

Page header, main, footer로 화면 구성. 사용할 때는 컴포넌트 담기 방식으로 조합

MenuPage 메뉴 목록 페이지에 들어갈 본문을 구성한다.

처음엔 App 컴포넌트 하나로 ui를 설계했다. 동작은 하지만 파악하기 어려운 코드다. App이 가지고 있는
여러 책임을 더 작은 컴포넌트로 위임했다. 각 컴포넌트는 책임이 적기 때문에 하는 일이 명확하다.
이러한 컴포넌트를 조합해서 화면을 구성했다.

이것이 페이지 하나를 리액트 컴포넌트로 만드는 방식이다. 앞으로 남은 두 화면도 같은 방법으로 진행하겠다.
