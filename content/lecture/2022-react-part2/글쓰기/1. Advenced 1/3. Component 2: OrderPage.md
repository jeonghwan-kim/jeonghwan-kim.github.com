# 3장. UI컴포넌트 2: 주문내역 화면

주문내역 화면을 만들어 볼 것이다. 이전 장에서 만든 컴포넌트를 조합하자. 새로운 컴포넌트도 만들자.

## 컴포넌트 계층 구조로 나누기

이전 장에서는 전체 화면을 만들고 난 후 각 컴포넌트를 만들었다. 이번에는 컴포넌트를 설계하고 이것을
조합해서 화면을 만들어 보자. 리액트로 생각하기에서 말하는 것 처럼 말이다.

컴포넌트 계층을 만들어 보자.

// todo ![주문내역 화면 설계]()

OrderPage 주문내역 화면

Page 상단/중앙/하단 페이지 구성

Title 화면 제목

Navbar 네비게이션바
→ 여기까지는 이미 만들어 둔 컴포넌트다.

추가할 컴포넌트 계층을 분석해 보자.

Card 카드. 세 개의 카드이다. 헤더, 본문, 푸터로 구성된다.

OrderStatusCard 주문 상태 정보 카드

OrderPaymentCard 주문 결재 정보 카드

OrderAddressCard 주문 수령지 정보 카드

## 리액트로 정적인 버전 만들기

API 연동하지 말고 정적인 버전을 먼저 만들어 보겠다.

## 단일 컴포넌트: <OrderPage>

```jsx
// src/pages/OrderPage.jsx
import Page from "../Page"

const OrderPage = () => (
  <Page header={<Title>주문내역</Title>} footer={<Navbar />}>
    <div className="OrderPage">주문내역 화면</div>
  </Layout>
)

export default OrderPage
```

전체 윤곽을 먼저 잡았다. Page 컴포넌트의 역할이다. 녀석에게 header, footer를 전달 하면 각 각
위, 아래에 전달한 엘리먼트를 렌더할 것이다. 그리고 children으로 전달한 앨리먼트는 중앙에 그리는
것이 Page 컴포넌트가 하는 일이다.

"주문내역"이란 제목이 오도록 Title 컴포넌트를 Page 컴포넌트의 header 속성에 전달했다. 하단
네비케이션 바가 위치하도록 footer 속성에 Navbar 컴포넌트를 전달했다. 아직 선택된 메뉴가
"주문내역"은 아니다. 이후 고급주제 2편의 라우터 장에서 만들것 것이다. children은 아직
구현전이라 텍스트만 전달했다. 전체 윤곽이 이렇게 나올 것이다.

// todo ![주문내역 화면 전체 윤곽]()

이미 만들어둔 작은 컴포넌트를 조합해서 만들었기 때문에 무척 신속하게 화면 윤곽을 만들 수 있었다.
이것이 바로 모듈화된 컴포너트를 명시적으로 사용한 효과이다.

## 카드 컴포넌트: Card

페이지 메인 컨텐츠를 살펴보자. (이미지 번호) 카드 타입의 UI다. <Card> 컴포넌트를 만들어보자.

```jsx
// src/components/Card.jsx
const Card = () => (
  <div className="Card">
    <header>헤더</header>
    <main>본문</main>
    <footer>푸터</footer>
  </div>
)
```

카드에 이미 만들어 놓은 스타일을 확인해 볼 용도로 만든 빈 껍데기 컴포넌트다.

카드 ui를 보면서 데이터 목록은 세 카드 모두 공통이다. 헤더와 푸터는 없는 경우도 있다. 이를 수용하기
위해 카드 컴포넌트를 변경해보자.

```jsx
const Card = ({ header, data = [], footer }) => (
  <div className="Card">
    {header && <header>{header}</header>}
    <main>
      {data.map(({ term, description }) => (
        <dl key={term}>
          <dt>{term}</dt>
          <dl>{description}</dl>
        </dl>
      ))}
    </main>
    {footer && <footer>{footer}</footer>}
  </div>
)

export default Card
```

## (실습)카드 컴포넌트 조합 OrderXXXCard

Card 컴포넌트의 특수한 조합이 바로 아래세 가지 컴포넌트가 될 것이다.

```jsx
<OrderStatusCard>
<OrderPaymentCard>
<OrderAddressCard>
```

## (풀이) 카드 컴포넌트 조합

가장 단순한 OrderAddressCard 부터 만들어 보자. 데이터 목록만 나열하기 때문에 Card 컴포넌트에
data 속성만 사용하자. 카드 컴포넌트는 이 값을 가지고 리스트 렌더링을 수행할 것이다.

```jsx
// src/pages/OrderPage/OrderAddressCard.jsx
const OrderAddressCard = () => (
  <Card
    data={[
      { term: "주문일시", description: new Date().toLocaleDateString() },
      { term: "주문번호", description: "ABCD1234" },
    ]}
  />
)
```

다음으로 data 뿐만 아니라 header도 그려야하는 OrderPaymentCard를 만들어 보자.

```jsx
// src/pages/OrderPage/OrderPaymentCard.jsx
const OrderPaymentCard = () => (
  <Card
    header={
      <>
        총 결제금액: 7,000원
        <br />
        결제 방법: 마이페이
      </>
    }
    data={[
      { term: "메뉴가격", description: "6,000원" },
      { term: "배달료", description: "3,000원" },
      { term: "할인금액", description: "2,000원" },
    ]}
  />
)
```

마지막으로 footer까지 있는 OrderStatusCard를 만들자.

```jsx
// src/pages/OrderPage/OrderStatusCard.jsx
const OrderStatusCard = () => (
  <Card
    header={
      <>
        <strong>주문이 완료되었습니다</strong>
        <br />
        짜장면
      </>
    }
    data={[
      { term: "주문일시", description: new Date().toLocaleDateString() },
      { term: "주문번호", description: "ABCD1234" },
    ]}
    footer={
      <>
        <Button>전화</Button>
        <Button>가게위치</Button>
      </>
    }
  />
)
```

이렇게 조합해서 만든 세 개 컴포넌트를 이용해서 주문내역 페이지를 완성하자.

```jsx
const OrderPage = () => (
  <div className="OrderPage">
    <Page header={<Title>주문내역</Title>} footer={<Navbar />}>
      <OrderStatusCard />
      <OrderPaymentCard />
      <OrderAddressCard />
    </Page>
  </div>
)
```

## 컴포넌트의 State 정하기

정적인 버전의 UI를 만들었으면 이제 UI의 상태를 정해야하는 단계다. 페이지에서 새로 추가된 컴포넌트는
Card와 XXXCard 컴포넌트다. 먼저 Card는 상태를 가질 수 없다. 모두 props를 통해 전달 받는다.
XXXCard는 어떤가? 상태가 필요한다. 즉 order라는 상태를 가진다. 전체 데이터를 가지지는 않지만
order 데이터의 일부를 ui 렌더에 사용한다. 세 개 컴포넌트가 동일한 주문 정보를 사용하기 때문에
이보다 상위 컴포넌트에 상태를 두는것이 맞다.

OrderPage 컴포넌트? 그렇다. 이 컴포넌트가 order 상태를 사용하는 최상위다. order 상태를
관리하기위해 함수 컴포넌트를 클래스 컴포넌트로 변경하자. 그리고 orderApi를 통해 order 데이터를
가져오자.

```jsx
// src/pages/OrderPage/index.jsx
class OrderPage extends React.Component {
  constructor() {
    super()

    // order 상태를 이 컴포넌트가 관리할 것이다.
    this.state = {
      order: null,
    }
  }

  async componentDidMount() {
    // 컴포넌트 마운트 직후 api 를 호출해 order 정보를 가져올 것이다.
    const order = await orderApi.fetchMyOrder()
    this.setState({ order })
  }

  render() {
    // order 상태로 렌더링할 것이다.
    const { order } = this.state
    return (
      <div className="OrderPage">
        <Page header={<Title>주문내역</Title>} footer={<Navbar />}>
          {order && (
            <>
              // 상태를 각 컴포넌트의 props로 주입한다.
              <OrderStatusCard {...order} />
              <OrderPaymentCard {...order} />
              <OrderAddressCard {...order} />
            </>
          )}
        </Page>
      </div>
    )
  }
}
```

## 중간 정리

메뉴 목록화면과 다르게 컴포넌트 계층 구조를 먼저 나누었다.

정적인 버전을 만들었다.

이미 제작한 Page, Title, Navbar 컴포넌트를 재활용했다.

Card 컴포넌트를 만들고 이를 조합한 특수한 카드컴포넌틑 세 개를 만들었다.

이 모든 컴포넌트를 조합해서 OrderPage 컴포넌트를 만들었다.

ui 렌더를 위한 최소한의 상태를 정의하고 위치를 정했다. 상태를 사용할 최상위 컴포넌트인 OrderPage 에 위치했다.

(학습결과: 리액트로 사고하기 - 훈련1)
