# 4장. UI컴포넌트 3: 장바구니 화면

마지막 화면이다. 장바구니 화면을 만들어 보자.

지난 장에서 리액트로 사고하기 접근법으로 화면을 개발했다. 이번에도 반복 연습하겠다.

## 컴포넌트 계층 구조로 나누기

먼저 컴포넌트 계층을 나누어 보자.

```
<CardPage> 장바구니 화면
  <Page> 화면 배치
    <Title> 화면 제목 (수정)
    <MenuItem> 메뉴 아이템 (수정)
      <Button> 버튼
    <OrderForm> 주문 정보입력폼 (신규)
      <FormControl> 레이블과 필드 (신규)
    <PaymentButton> 결제 버튼 (신규)
      <Button> 버튼
```

## 리액트로 정적인 버전 만들기

정적인 버전을 만들자
기존것을 조합해서 만들면 쉽게 화면을 만들 수 있다.

```jsx
// src/pages/CartPage/index.jsx
const mockMenu = {
  id: "menu-id-001",
  name: "해물 계란 라면",
  price: 6000,
  thumbnail: "./images/menu-해물계란라면.jpg",
}

const CartPage = () => (
  <div className="CartPage">
    <Page header={<Title>장바구니</Title>} footer={<Button>결제하기</Button>}>
      <MenuItem {...mockMenu} />
    </Page>
  </div>
)
```

목업 데이터를 가지고 장바구니 화면 얼개를 만들었다.

// todo ![]()

MenuItem 을 재활용했지만 디자인과 다르다. 바로 주문하기 버튼이 없어야한다.

## Title 다시보기

디자인으로 보면 타이틀 좌측에 뒤로가기 버튼이 있다. 현재 Title은 제목만 노출하는 컴포넌트다.
어떤 타이틀은 뒤로가기 버튼이 있는 것이다.

컴포넌트를 사용하는 측에서 이를 정해야한다. Title을 사용할 때 '이건 제목만 있어', '이건 제목과
뒤로가기 버튼이 있어'라고 알려주어야한다. 바로 컴포넌트의 인자인 props 객체를 사용하면 되겠다.

Title 컴포넌트에 children 외에 backUrl이란 문자열 속성을 추가하자.

```jsx
const Title = ({ backUrl = false, children }) => {
  if (backUrl) {
    return (
      <>
        <a href={backUrl} />
        <h1 style={{ paddingRight: "44px" }}>{children}</h1>
      </>
    )
  }

  return <h1>{children}</h1>
}
```

backUrl이 있을 경우 이 주소를 이용해 링크를 만들었다. 그리고 타이틀을 출력한다. backUrl이 없으면
이전처럼 타이틀 문자열만 노출할 것이다.

뒤로가기 버튼이 있는 장바구니 화면에서는 다음과 같이 Title을 사용할 수 있다.

```jsx
const CartPage = () => {
  return (
    <div className="CartPage">
      <Page
        header={<Title backUrl="/">장바구니</Title>}
        footer={<Button form="order-form">결제하기</Button>}
      >
  // ...
}
```

## MenuItem 다시보기

메뉴 아이템 컴포넌트를 좀 확장하자. 버튼이 있는 버전과 없는 버전이다. 사용하는 측에서 어떻게
조합하느냐에 따라서 버튼 렌더링을 달리하면 되겠다.

그럼 어떤 프롭스를 사용해야할까? MenuItem의 프롭스를 다시 보자.

name
price
thumbnail

메뉴 데이터와 관련한 프롭스 뿐이다. 직관적으로 orderable이란 속성을 추가하자. 주문할 수 있는 메뉴
아이템이니깐 버튼을 노출하는 것이다.

```jsx
const MenuItem = ({ menu, orderable }) => {
  return (
    <div className="MenuItem">
      <div className="description">
        <h2>{name}</h2>
        <div>{price.toLocaleString()}원</div>
        {orderable && (
          <Button styleType="brand" onClick={() => console.log("click")}>
            주문하기
          </Button>
        )}
// ...
```

메뉴 목록 화면에서는 주문하기 버튼이 있어야하기 때문에 `<MenuItem menu={} orderable>`로
사용하는 걸로 바꾼다. 장바구니 화면에서는 주문하기 버튼이 없기 때문에 `<MenuItem menu={}>`로
사용한다.

## 폼컨트롤 컴포넌트: <FormControl>

설계한 것 중 FormControl을 만들어 보자. 레이블과 입력 필드를 렌더링하는 역할이다.

미리 만들어둔 스타일을 이용해서 정적 버전을 만들어 보자.

```jsx
const FormControl = () => (
  <div className="FormControl">
    <label htmlFor="name">
      이름<span className="required">*</span>
    </label>
    <input id="name" />
  </div>
)
```

이름 입력 필드다. 입력 필드 이름이 label 엘리먼트로 있고 필수 입력을 표시하는 별표도 뒤에 따라온다.
htmlFor로 필드 아이디와 같은 값을 지정했는데 아래있는 input 엘리먼트를 가리킨다.

// tod o![]()

레이블을 클릭하거나 인풋 요소를 클릭하면 인풋에 커서가 생길것이다.

여기서 어떤 것이 이 컴포넌트만의 역할일까? 먼저 필드 이름은 바뀔수 있다. 사용할 때마다 달라질수 있다.
필수입력 여부도 달라질수 있다. 어떤 필드는 선택사항이기 때문이다. 입력 요소도 input만 있는 것은 아니다.
입력할 데이터 형태에 따라 select, radio, textarea가 될수 있다.

이런 변화를 모두 받아들이려면 폼 컨트롤러는 이 로직을 놓아야 한다. 스스로 갖고 있으면 그 기능으로
한정 되어 버리기 때문이다. 사용하는 쪽에서 정하는 것이다. 컴포넌트는 이러한 성격의 기능을 props로
받는다. 이렇게 변경해보자.

```jsx
const FormControl = ({ label, htmlFor, required, children }) => (
  <div className="FormControl">
    <label htmlFor={htmlFor}>
      {label}
      {required && <span className="required">*</span>}
    </label>
    {children}
  </div>
)
```

프롭스로 네 가지를 받았다. label은 필드 이름으로 사용할 문자열이다. htmlFor는 레이블이 가리킬
필드의 아이디다. required 플래그에 따라서 필수 표시가 될 것이다. children은 사용할 필드 엘리먼트다.

먼저 만들었던 정적버전을 FormControl로는 이렇게 사용할 수 있다.

```jsx
<FormControl label="이름" htmlFor="name" reuqired>
  <input id="name />
</FormControl>
```

자 그러면 이 컴포넌트를 사용해서 OrderForm 컴포넌트를 만들 차례다.

## 주문폼 컴포넌트: OrderForm, 비제어 컴포넌트

우선 정적 버전의 OrderForm 컴포넌트를 만들어 보자. 디자인 상으로는 입력 필드 뿐이다. 위에서 만든
FormControl를 사용하자.

```jsx
const OrderForm = () => {
  return (
    <form className="OrderForm">
      <FormControl label="주소" htmlFor="deliveryAddress" required>
        <input
          type="text"
          id="deliveryAddress"
          placeholder="배달받을 주소를 입력하세요"
          required
          autoFocus
        />
      </FormControl>
      <FormControl label="연락처" htmlFor="deliveryContact" required>
        <input
          type="text"
          id="deliveryContact"
          placeholder="연락처를 입력하세요"
          pattern="^\d{2,3}-\d{3,4}-\d{4}$"
          required
        />
      </FormControl>
      <FormControl label="결재수단" htmlFor="paymentMethod" required>
        <select name="paymentMethod" id="paymentMethod" value="">
          <option value="마이페이">마이페이</option>
          <option value="만나서 결제">만나서 결제</option>
        </select>
      </FormControl>
      <FormControl label="가게 사장님께" htmlFor="messageToShop">
        <textarea name="messageToShop" id="messageToShop"></textarea>
      </FormControl>
      <FormControl label="라이더님께" htmlFor="messageToRider">
        <textarea name="messageToRider" id="messageToRider"></textarea>
      </FormControl>
    </form>
  )
}
```

이런 화면이 나올 것이다.

// todo ![]()

각 인풋 요소를 클릭하고 키보드로 값을 입력할 수 있다.

잠깐 생각해 보자. 1부에서는 입력값을 컴포넌트 상태로 관리했었다. 간단히 설명하면 컴포넌트의 상태
값을 입력 필드의 value에 연결한다. 필드에 변경 이벤트가 발생하면 this.setState 메소드를
호출해서 컴포넌트의 상태에 입력값을 저장한다. 리액트는 상태가 변경되면 컴포넌트를 다시 렌더링한다.
그러려면 필드의 value에 바인딩된 값이 다시 화면이 나올 것이다. 이러한 것을 '제어 컴포넌트'라고 한다.

반면 OrderForm은 어떤 상태도 필드의 value에 연결하지 않았다. onChange에 핸들러를 추가하지도
았았다. 그런데도 입력할 수 있는 이유는 뭘가? 바로 브라우져에서 상태관리를 하기 때문이다.
리액트를 떠나서 이렇게 폼 관리하는것이 일반적이다. 하지만 리액트를 사용하는 관점에서 보자면 이것은
"비제어 컴포넌트"이다. 리액트 상태로 관리하지 않았기 때문이다.

간단한 폼은 비제어 컴포넌트를 쓰는 것이 간편하다. 한편 입력값 검증, 오류 UI 처리 등 세세한 폼
처리를 위해서는 제어 컴포넌트가 유리하다. 지금은 비제어 컴포넌트로 구현을 하고 이후 훅 편에서 이것을
제어 컴포넌트로 만들자. 그리고 재활용 할수 있는 폼 컴포넌트를 만드는 방법도 함께 소개할 것이다.

자 그럼 다시 OrderForm으로 돌아와서. 폼이니깐 당연히 제출(submit) 처리를 해야한다. 보통
submit 이벤트는 form 안에 있는 버튼을 클릭하거나 입력 필드에서 엔터키를 입력하면 발생한다.

엔터키를 입력해 보자. 이상하다. submit 이벤트를 잡지 못한다. 버튼이 form 밖에 있기 때문인것 같다.
그럼 button에 도 form을 가리키는 코드가 필요하다.

```jsx
// src/pages/CartPage/OrderForm.jsx
const OrderForm = () => {
  const handleSubmit = e => {
    e.preventDefault();
    console.log('submit')
  }

  return (
    <form className="OrderForm" id="order-form" submit={handleSubmit}>

  //...
}

// src/pages/CartPage/index.jsx
const CartPage = () => (
  <div className="CartPage">
    <Page
      header={<Title>장바구니</Title>}
      footer={<Button form="order-form">결제하기</Button>}
    >
  // ...
}
```

폼에 아이디를 달았다. 버튼이 가리킬수 있도록 말이다. 버튼에서는 form 속성을 이용해서 폼 아이디를
전달했다.

이제 버튼을 클릭해보자. submit 이벤트가 동작할 것이다. 인풋 필드중 하나에서 엔터를 입력해도
submit 이벤트가 발생한다.

그럼 submit 처리를 누가 할 것인가?

OrderForm이 할수도 있을 것이다. 왜냐하면 입력한 폼 값을 모두 알고 있기 때문이다. OrderForm
제출을 하고 나면 후속은 뭔가? 요구사항에 따르면 사용자에게 확인 받고 결제 api를 수행한다. 그리고
주문 내역 화면으로 이동하는 기능을 해야한다. 이것을 OrderForm 컴포넌트가 하는게 맞을가?
좀 버거워 보인다. 사용자 입력을 받는 폼인데 너무 많은 일을 한다.

부모 컴포넌트인 CartPage는 어떤가? api를 호출해서 장바구니 화면을 그린다. 이곳에서 폼을 사용하고
제출 후속처리를 하는것이 더 맞다.

CartPage → OrderForm 구조에서 폼의 submit을 어떻게 CartPage로 알리수 있을까? 지금까지는
부모 컴포넌트에서 자식 컴포넌트로 데이터를 전달하는 방식을 사용했다. 자바스크립트에서 이걸 역전시키는
방법은 콜백이다. 함수를 인자로 넘겨서 이를 받는 쪽에서 제어하는 것이다.

OrderForm 컴포넌트는 부모인 CartPage에서 전달한 콜백함수를 갖고 있다가 적당한 시점에 호출한다.
CartPage는 이 콜백 함수 본문을 알고 있으니깐 여기서 메세지를 받을수 있는 구조이다. 리액트로
사고하기의 5단계 역방향 데이터 흐름 추가하기는 props에 콜백함수를 사용해서 데이터 흐름을 거꾸로 하는
것이다.

```jsx
const OrderForm = ({ onSubmit }) => {
 const handleSubmit = (e) => {
    e.preventDefault();

    onSubmit();
  };

  return (
    <form
      className="OrderForm"
      id="order-form"
      onSubmit={handleSubmit}
     >
  // ...
}
```

## Ref와 돔(DOM)

참고:

- https://ko.reactjs.org/docs/refs-and-the-dom.html
- https://jeonghwan-kim.github.io/2022/05/31/react-ref

// todo ref 를 소개하고 다음장에서 ref를 사용한다

## 주문폼 컴포넌트: <OrderForm> 2, ref

orderForm이 onSubmit을 호출해서 폼 제출을 알 수 있게 되었다. 제출시 사용자가 입력한 데이터를
같이 보내주면 좋겠다. 사실 그게 폼 컴포넌트의 역할이다.

비제어 컴포넌트에서 엘리먼트의 입력 데이터를 사용하려면 돔에 직접 접근해야한다. 이를 위해서 리액트의
ref를 사용해해야한다. ref는 돔을 접근하기 위한 리액트 기능이다.

이렇게 사용해보자.

```jsx
class OrderForm extends Component<OrderFormProps> {
  readonly formRef = createRef<HTMLFormElement>();

  constructor(props: OrderFormProps) {
    super(props);

    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleSubmit: FormEventHandler = (e) => {
    const { onSubmit } = this.props;

    e.preventDefault();

    const deliveryAddress = this.getInputValueByName("deliveryAddress");
    const deliveryContact = this.getInputValueByName("deliveryContact");
    const paymentMethod = this.getInputValueByName("paymentMethod");
    const messageToShop = this.getInputValueByName("messageToShop");
    const messageToRider = this.getInputValueByName("messageToRider");

    onSubmit({
      deliveryAddress,
      deliveryContact,
      paymentMethod,
      messageToRider,
      messageToShop,
    });
  };

  getInputValueByName(name: string) {
    const inputElement = this.formRef.current?.elements.namedItem(
      name
    ) as HTMLInputElement;
    return inputElement.value;
  }

  render() {
    return (
      <form
        id="order-form"
```

form 엘리먼트의 ref에 formRef를 연결했다. 제출 이벤트를 처리하는 handleSubmit이 나중에
실행되는데 이때 formRef를 통해서 form 엘리먼트의 돔에 접근할 수 있게 되었다.
getInputValueByName 이라는 헬퍼 함수를 두어서 입력한 값을 가져왔다. formRef의 current
속성을 보는데 엘리먼트 메소드 중 NamedItem 함수로 인풋 엘리먼트를 찾았다. 브라우져가 저장한 값을
value 속성을 통해 조회한다.

OrderForm을 사용한 CartPage 컴포넌트는 이렇게 수정하자.

```jsx
const CartPage = () => {
  const handleSubmit = (values) => {
    // 폼을 제출하면 입력한 값이 values 인자로 들어올 것이다.
    console.log(values);
  };

  return (
    <div className="CartPage">
      <Page
        header={<Title>장바구니</Title>}
        footer={<Button form="order-form">결제하기</Button>}
      >
        <MenuItem menu={menuMock} />
        <OrderForm onSubmit={handleSubmit} />
      </Page>
    </div>
  );
```

## 주문버튼 컴포넌트: PaymentButton

마지막으로 결제하기 버튼인 PaymentButton 컴포넌트를 만들 차례다. 이것은 버튼이기 때문에 기존에 만든
Button 컴포넌트를 조합하면 되겠다. 버튼 엘리먼트를 노출하고 클릭을 처리하는 기능을 재사용할 수
있기 때문이다.

```jsx
// src/pages/CartPage/PaymentButton.jsx
const PaymentButton = () => {
  return (
    <div className="PaymentButton">
      <Button
        styleType="brand-solid"
        block
        style={{ padding: "12px 0" }}
        form={"order-form"}
      >
        결제하기
      </Button>
    </div>
  )
}
```

styleType block 속성을 사용해 색상이 채워지고 가로 너비를 차지하는 모양의 Button 컴포넌트
만들었다. 그리고 order-form 아이디를 갖은 폼 엘리먼트를 가리키기 위해 form 속성에 아이디 값을
지정했다. 버튼을 안에 패딩을 추가해서 디자인과 맞추었다.

Button 컴포넌트를 직접 사용할 수도 있었을 것이다. 하지만 이러한 구현 상세를 PyamentButton
컴포넌트 안으로 숨겼다. 그리고 이렇게 사용할 수 있다.

```jsx
<Page footer={<PaymentButton />} />
```

구현 상세를 footer에 전달하는 것보다 이를 추상화한 PaymentButton 컴포넌트를 전달하는 것이 더
빨리 읽힌다. 이렇게 컴포넌트로 추상화한 코드는 비교적 쉽게 읽힌다.

## 컴포넌트의 State 정하기

정적인 버전의 UI를 모두 만들었다. 이제는 화면에서 사용할 상태를 정할 차례다. 어떤 상태가 필요한가?

장바구니에 담은 상품 정보다. 이 정보는 MenuItem 컴포넌트에 의해 그려진다. 이 컴포넌트는 meun
속성으로 데이터를 받아서 그리기 때문에 상위 컴포넌트에서 menu 상태를 가지고 있어야 할 것이다.

OrderPage는 menu 데이터를 가져와서 상태로 저장해야 한다. 그리고 자식 컴포넌트에게 이를 전달할
책임을 진다.

```jsx
class CartPage extends Component {
  constructor() {
    super()

    this.state = {
      menu: null,
    }

    this.handleSubmit = this.handleSubmit.bind(this)
  }

  async componentDidMount() {
    // menu id는 나중에 url을 통해 가져올 것이다.
    const menu = await menuApi.fetchMenu("menu-id-001")
    this.setState({ menu })
  }

  handleSubmit(values) {
    console.log(values)
  }

  render() {
    const { menu } = this.state

    return (
      <div className="CartPage">
        <Page
          header={<Title backUrl="/">장바구니</Title>}
          footer={<PaymentButton form="order-form" />}
        >
          {menu && <MenuItem menu={menu} />}
          <OrderForm onSubmit={this.handleSubmit} />
        </Page>
      </div>
    )
  }
}
```

OrderPage 컴포넌트에 있어야한다.

## 중간 정리

이전 장과 같은 방식으로 훈련했다.

컴포넌트 계층 구조를 먼저 나누었다.

정적인 버전을 만들었다.
이미 제작한 Page, Title, Navbar, MenuItem 컴포넌트를 재활용했다.

Title과 MenuItem은 이전 메뉴 목록 화면에서도 사용하지만 미묘하게 다르다. Title에는 뒤로가기
버튼이 있고 MenuItem에는 주문하기 버튼이 없다. 이러한 확장을 위해 컴포넌트 props를 추가해 해결했다.

FormControl과 OrderForm 컴포넌트를 만들었다.
리액트의 Ref를 이해했다.

이 모든 컴포넌트를 조합해서 CartPage 컴포넌트를 만들었다.

ui 렌더를 위한 최소한의 상태를 정의하고 위치를 정했다. 상태를 사용할 최상위 컴포넌트인 CartPage에
위치했다.

(학습결과: 리액트로 사고하기 - 훈련2)

CartPgae 컴포넌트 하나로 장바구니 화면을 만들었다.

리액트로 생각하기 5단계로 컴포넌트를 재구성했다.

Layout 활용

MenuItem, OrderableMenuItem 컴포넌트를 만들었다. (조합방식: 특수화)

FormControl 레이블과 필드를 렌더하는 컴포넌트. 이후 폼을 만들때 다시 볼 것이다.

OrderForm 비제어 컴포넌트르 보았다.

PaymentButton button을 조함해서 만듬. (조합방식: 컴포넌트 담기)

리액트로 사고하기 두번째로 했다. 컴포넌트 계층 나누기 → 정적버전 만들기 → State 정하기에 이어
역방향 데이터 흐름을 추가했다.
