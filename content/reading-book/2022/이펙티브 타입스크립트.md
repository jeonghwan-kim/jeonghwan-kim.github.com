이펙티브 타입스크립트 / 덴 벤더캄

# 서문

두 번째 표준책. 중/상급자 대상

제목 암기 \*\*\*

# 1장. ts 알아보기

ts, js 관계

- ts는 js의 상위 집합
- ts는 js의 런타임 동작을 모델링
- tsc는 타입 추론도.

설정

- noimplicitAny: 변수에 미리 정한 타입이 있어야.
- strictNullChecks: null, undefined가 모듭 타입에 허용 안되.
- strick. 상기 두 개 모두 사용

코드 생성과 타입 무관

- 컴파일과 타입 검사는 별개
- noEmitOnError: 오류 발행하면 컴파일 안됨
- 런타임 타입 체크
  - 속성 검사 ???
  - 태근 속성 검사 (tagged union)
  - 타입과 값을 사용하려면 class 사용

구조적 타이핑 익숙해 지기

- 덕 타이핑: 어떤 매개변수 값이 모두 주어진다면 타입에 무관
- 타입스크립트가 이를 모델링하기 위해 "구조적 타이핑" 사용 → 여전히 모호
- 봉인된 vs 열린 타입. ts는 후자.
- 클래스에서도 구조적 타이핑은 혼란

```ts
class Foo {
  constructor(a: number) {
    this.a = a
  }
}
const f: Foo = { a: 1 } // 가능
```

- 테스트에 용이. 특정 구현에서 추상화 분리.
  - PostgreDB → DB

any 타입 지양

- any 덕에 점진적, 선택적. 하지만
- 타임 안정성 없어
- 함수 시그니쳐 무시
- 언어 서비스 미적용 → 생산성 하
- 코그리팩토링 안됨
- 설계 감춤. 예: 상태 객체 → ?
- 신뢰도 하

# 2장. 타입스크립트의 타입시스템

편집기 사용 → 타입 시스템 탐색

- 언어 서비스를 적극 활용. 코드 자동완성, 명세

타입 = 값 집합

```ts
never < unit type(literal type) < uniton type, intersection type < unknown
<K extends string> → 제너릭 한정자
```

- string 상속을 객체 상속 관점에서 보면 어려워
- 집합 관점으로 봐야

타입 공간과 값 공간의 심벌 구분
-type, interface → 타입 공간
-class, enum → 타입/값 공간

타입단언보다 타입 선언 -안전성: 타입 단언은 타임 체크 안함. 런타임 문제 발생 -타인 단언 사용하려면: DOM, 타입 추론보다 확신해야

10.객체 레퍼타입 피하기

- 기본형과 객체 레퍼타입 구분해야.
- 래퍼타입은 new 없이 생성하는 원시타입. → 몰랐음.
- js는 기본형과 객체 타입을 서로 자유롭게 변환
- 래퍼 객체 덕에 기본형 값에 메서드 사용할 수.

잉여속성 체크의 한계 인지하기

- 객체 리터럴을 변수 할당. 함수에 매개 변수 전달시 "잉여속성 검사".
- "구조적 할당 가능성 검사"와 역할이 다름.
- 임시 변수 도입하면 잉여 속성체크 건너 뛸수 있어.
- "공통 속성 검사"도 있음. 약한 타입에 값 할당 시 검사.
- 참고: 2021-09 이펙티브 타입스크립트 11. 잉여 속성 체크의 한계

함수 표현식에 타입 적용

- 함수 표현식 vs 함수 문장. 전자 권장. 타입 재활용 가능
- 함수 매개변수 타입 정의보다 함수 전체 타입 정의 해야.
- typeof fn 으로 타입 재활용 → 그러려면 함수 표현식 써야.

타입과 인터페이스 차이점 알기

- 비슷한점: 인덱스 시그니처, 함수 타임, 제너릭, 클래스로 구현
- 타입: 유니온, 인터섹션, 튜플 타입. 배열 타입. 복잡한 타입
- 인터페이스: 보강 → 선언 병합 (declaration merging)

타입 연산과 제너릭 사용으로 반복 v

- 타입 중복은 코드 중복만큼 많은 문제
- 타입에 이름 붙이기(명명된 타입)
- extends, uniton, intersection
- Pick, Partial, typeof → 값에서 타입 정의, ReturnType
- 제너릭에 extends → 매개변수 제한, keyof

동적 데이터에 인덱스 시그니쳐

- csv처럼 예측하기 어려운 데이터를 다룰때 인덱스 시그니쳐 사용.
- 값을 as unknown as ProductRow 로 타입단언해서 사용.
  - 런타임 보장 안됨. undefined 타입을 추가해서 사용

number 인덱스 시그니쳐보다는 Array, 튜플, ArrayLike

number 인덱스 시그니쳐보다는 array, 튜플, arrayLike

매핑된 타입 사용해 값을 동기화

```ts
const REQUIRES_UPdate:: {[k in keyof ScatterProps]: boolean}
```

# 3장. 타입추론

추론 가능 타입을 사용, 장황한 코드 방지

다른 타입에는 다른 변수 사용

타입 넓히기

- widening
- 명확성과 구체성의 균형

타입 좁히기

- 사용자 정의 타입 가드
- 태그된/구별된 유니온

한꺼번에 객체 생성. 객체에 조건부 속성을 추가하는 방법

일관성 있는 별칭

- 별칭은 타입 좁히기를 방해. 일관적으로 써야

콜백대신 async 함수

- 코드 작성 쉬워
- 타입 추론 쉬워

타입추론에 문맥이 어떻게 사용되는지

- 문맥과 값을 분리하면 발생하는 문제
- as const (상수 문맥)
- 콜백을 상수로 뽑아내면 문맥을 소실

함수형 기법과 라이브러리로 타입 흐름 유지하기

- 내장 함수 활용해야. Array.#.flat()
- 외부 라이브러리 활용해야. lodash, underscore

# 4장. 타임 설계

유효한 상태만 표현하는 타입을 지향하기

사용할 때는 너그럽게, 생성할 때는 엄격하게

- 실습해보자. 눈으로는 모르겠다.

문서에 타입 정보를 쓰지 않기

타입 주변에 null 값 배치하기

- 결국 null 체크 난무. 버그를 양산

유니온 인터페이스보다 인터페이스의 유니온 사용

- 태그된 유니온?

string 타입보다 구체적 타입

부정확한 타입보다 미완성 타입.

- 언어서비스(자동완성)와 타입체커
- 정확도 뿐만 아니라 개발 경험도 중요

데이터가 아닌, api와 명세를 보고 타입 만들기

- apollo: graphQL → TS → 블로그 적용

해당 분야의 용어로 타입 이름 짓기

- 자체 용어 만들지 말고

공식 명칭에는 상표(brand) 붙이기

# 5장. any 다루기

any 타입은 가능한 한 좁은 볌위에서만 사용

- 사용범위 최소.
- 함수 반환히 any x
- @ts-ignore 고려

any를 구체적으로 변형해서 사용

함수 안으로 타입 단언문 감추기

any 진화 이해

unknown, any 대신
unknown, any, never, {}, object 차이 알기

키패치보다 안전한 타입 사용
보강 기법 활용
더 구체적인 타입 선언/단언

타입커버리지 추적
타입 안전성 유지
npx type-coverage

# 6장. 타입 선언과 @types

devDependencies에 typescript와 @types 추가

타입선언 관련 3가지 버전 이해
라이브러리 / @types / ts버전
타입을 라이브러리에 vs DefinitelyTyped에

공개 api에 등장하는 모든 타입 export

api 주석에 tsdoc 사용
인라인 주석 말고 jsdoc 사용. 편집기도움 받을 수
ts관점에서는 tsdoc이라 부르기도. 마크다운 지원

콜백에서 this에 대한 타입 제공하기

오버로딩 타입보다 조건부 타입 사용

의존성 분리 위해 미러타입 사용
필요한 선언부만 추출. 작성 코드에 넣는 것. CsvBuffer

테스팅 타입의 함정

# 7장. 코드를 작성하고 실행하기

ts 기능보다 es 기능 사용하기
enum, 매개변수 속성, 데코레이터 지양

객체 순회
keyof, Object.entries

dom 계층 구조 이해
Node, element, HTMLElement, EventTarget 차이

정보 은닉용으로 private 사용 금지

소스맵을 사용하여 디버깅

# 8장. ts로 마이그레이션

모던 js로 작성
class, let/const, for-of, arrow function, 단축 객체 표현, 구조 분해 할당, 매개변수 기본값, async/await, Map/Set

ts 도입전에 @ts-check, jsdoc 시험해 볼것

allowJs

의존관계 따라 모듈 단위 전환
