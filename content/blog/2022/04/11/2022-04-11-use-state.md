---
title: "리액트 useState"
layout: post
category: dev
tags:
  - react
---

# 서론

함수 컴포넌트의 역할. 리액트 앨리먼트를 반환하다. 리액트가 알아서 그린다.
클래스보다 가볍고 사용하기 간편하다.

상태를 가진다면? 훅스.
훅스를 한 번 만들어 보자.

# 문제 제기

NameField 는 사용자에게 입력을 받을 수 있는 인풋 필드를 그리는 컴포넌트다.
input 앨리먼트를 갖는 리액트 앨리먼트를 반환하는 함수다.
이 앨리먼트는 name 변수에 할당한 "jeonghwan" 문자열을 value로 갖고 있다.
사용자가 입력 값을 변경하면 handleChange 함수를 통해 이벤트를 받을 수 있다.

```jsx
function NameField {
  const name = "jeonghwan";

  const handleChange = event => {
    console.log(event.target.value)
    // ?
  }

  return <input value={name} onChange={handleChange} />;
}
```

이런 모습의 UI를 그린다.

![NameField의 UI]()

인풋 필드에 값을 바인딩하려면 handleChange에서 value에 설정할 값을 바꿔 주어야 한다.
하지만 name 단순히 함수 본문 선언한 문자열 값이기 때문에 다시 설정할 수 없다.

let 키워드로 바꿔도 원하는 것을 얻을 수 없다.
함수 컴포넌트는 한 번 호출되어 결과값을 내 놓는 것으로 역할을 다했기 때문이다.
handleChange 함수안에서 name 값을 갱신하더라도 그 땐 이미 늦었다.
NameField 컴포넌트는 두 번 다시 불리 않는다.

# 두 가지 문제

입력값에 사용할 value 값을 어딘가에 저장해 두어야 한다.
이 값은 사용자의 입력에 따라 변하기 때문에 "상태(effect)"라고 부르자.
함수 컴포넌트인 NameField는 상태를 가지지 못하는 것이 문제다.

변하는 상태를 가지고 있다 하더라도 남은 문제가 있다.
이 상태를 인지하고 컴포넌트를 다시 그려야 하는데 한 번 호출할 함수를 다시 호출할 방법이 없다.

리액트 훅 중에 useState 훅을 사용하면 상태도 얻고 이 값의 변화에 따라 컴포넌트도 다시 그린다.
함수 컴포넌트 안에서 useState를 사용했을 뿐인데 어딘가에서 관리되는 상태가 있고 이 값의 변화에 따라 컴포넌트도 다시 그려 줬다면 리액트의 역할이 아닐까 가늠해 볼 수 있다.

# 구현 버전 1차

리액트에서 처리하는 이 두 가지 기능을 MyReact로 만들어 보자.

```js
function MyReact() {
  // 이름
  let name: string
  let isInitialized = false

  function useName(initilaName?: string): [string, (value: string) => void] {
    if (!isInitialized) {
      name = initilaName || ""
      isInitialized = true
    }

    // 이름 변경
    const setName = (nextName: string) => {
      name = nextName
    }

    return [name, setName]
  }

  return {
    useName,
  }
}
```

```js
const { useName } = (function MyReact() {
  let name: string;
  let isInitialized = false;

  function useName(initilaName?: string): [string, (value: string) => void] {
    // 클래스 컴포넌트의 forceUpdate를 흉내낸다.
    // 리렌더링을 유발하는 역할이다.
    const { forceUpdate } = useForceUpdate();

    if (!isInitialized) {
      name = initilaName || "";
      isInitialized = true;
    }

    const setName = (nextName: string) => {
      name = nextName;
      // 상태를 변경하고 리렌더링을 유발한다.
      forceUpdate();
    };

    return [name, setName];
  }

  return {
    useName,
  };
})();

// 구현을 위해 이곳만 리액트 훅을 사용한다.
function useForceUpdate {
  const [value, setValue] = React.useState(1);
  const forceUpdate = () => setValue(value + 1);
  return {
    forceUpdate,
  };
};
```

```js
const { useName } = (function MyReact(){/* 생략 */})();

function NameField {
  // useName을 이용해 name과 setName을 얻는다.
  const [name, setName] = useName("jeonghwan"); // name = "jeonghwan"

  const handleChange = event => {
    setName(event.target.value) // name = 사용자가 인풋 필드에 입력한 값
  }

  return <input value={name} onChange={handleChange} />;
}
```

# 다중 상태 관리

이름 필드 뿐만 아니라 주소 필드도 입력받는 UI를 만든다면?
지금의 구조로 가능할까? 우선 코딩해보자.

MyReact 함수 본문을 좀 더 범용적인 이름으로 바꿔보자.

```js
const { useState } = (function MyReact() {
  // 상태 값
  let value: string

  // 상태를 사용하는 함수
  function useState(initilaValue) {
    const { forceUpdate } = useForceUpdate()

    if (!isInitialized) {
      value = initilaValue || ""
      isInitialized = true
    }

    // 상태 변경
    const setValue = nextValue => {
      value = nextValue
      forceUpdate()
    }

    return [value, setValue]
  }

  return {
    useState,
  }
})()
```

이제 주소 필드를 위한 상태도 추가한다.

```js
const { useState } = (function MyReact(){/* 생략 */})();

function NameField {
  // useName을 이용해 name과 setName을 얻는다.
  const [firstname, setFirstname] = useState("jeonghwan"); // firstname = "jeonghwan" ?
  const [lastname, setLastname] = useState("kim"); // lastname = "jeonghwan" ?

  const handleChangeFirstname = event => {
    setFirstname(event.target.value) // firstname = 사용자가 인풋 필드에 입력한 값
  }

  const handleChangeLastname = event => {
    setFirstname(event.target.value) // firstname = 사용자가 인풋 필드에 입력한 값
  }

  return (
    <>
      <input value={firstname} onChange={handleChangeFirstname} />
      <input value={lastname} onChange={handleChangeLastname} />
    </>;
  )
}
```

어떻게 될까?

# 구현 버전 2차

다중을 위해서 이렇게 구현해 보자.

```js
function MyReact() {
  // 상태 목록
  const values: string[] = []
  // 각 상태의 초기화 여부 목록
  const isInitialized: (boolean | undefined)[] = []

  // 상태 목록에서 사용할 cursor를 받는다
  function useState(cursor: number, initilaValue?: string) {
    const { forceUpdate } = useForceUpdate()

    // 지정한 상태의 초기화 여부 값을 조회한다
    if (!isInitialized[cursor]) {
      // 지정한 상태의 값을 설정한다
      values[cursor] = initilaValue || ""
      isInitialized[cursor] = true
    }

    // 지정한 상태를 조회한다
    const value = values[cursor]
    const setValue = (value: any) => {
      // 지정한 상태의 값을 변경한다
      values[cursor] = value
      forceUpdate()
    }

    return [value, setValue]
  }

  return {
    useState,
  }
}
```

사용해보자

```jsx
```

그림으로 보면 이렇다.

```
상태 커서
```

# 결론

주의. 구현 방법일 뿐이지. 리액트가 이렇게 구현한 것은 아님.
