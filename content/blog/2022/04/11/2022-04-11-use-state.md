---
title: "리액트 useState는 어떻게 동작하는 걸까?"
layout: post
category: dev
tags:
  - react
featuredImage: coffee.jpg
---

함수는 값을 반환한다.
문자열, 숫자 같은 원시 타입의 값을 반환할 수도 있다.
객체나 배열같은 합성 타입의 값을 반환하기도 한다.

리액트 앨리먼트를 반환하는 함수를 리액트에서는 함수 컴포넌트(Function Component)라고 부른다.
클래스 컴포넌트에 비해 사용하기 간편한데 클래스와 함수를 사용할 때의 차이와 같다.

간편한 만큼 제약도 있다.
컴포넌트 생애 주기에 관여할 메소드가 없다.
컴포넌트가 생성되고 마운트 되고 업데이트 되는 시점에 관여할 수 없다는 것이다.

상태도 없다.
클래스 멤버 변수 state에 컴포넌트의 상태를 관리할 수 있다.
하지만 한번 호출되는 함수 컴포넌트는 값을 반환하면 그만일 뿐 상태랄 것이 없다.

그럼에도 불구하고 함수 컴포넌트는 [리액트 16.7 버전 이후 부터는 야심차게 준비한 api]()다.
앞으로 컴포넌트를 새로 만들때는 함수 컴포넌트를 이용하라고 한다.
물론 훅스(hooks)와 함께 말이다.

훅스는 함수 컴포넌트를 좀더 사용할만 하도록 만든다.
useState, useEffect 가 컴포넌트의 기능을 확장한다.
함수 컴포넌트가 에스프레소라면 훅스는 우유 거품이나 모카 크림이다.
여러 요구사항을 만족하는 컴포넌트를 만들때 함수 컴포넌트와 훅스를 이용해서 만들 수 있다.

![다양한 커피 메뉴(출처: unsplash.com)](coffee.jpg)

이 글에서는 함수 컴포넌트가 어떻게 상태 관리를 할 수 있는지 알아보겠다.
useState 함수를 만들어 보면서 리액트가 함수 컴포넌트에서 상태를 관리하는 방식을 추측해 볼것이다.
물론 여기 나온 멘탈모델은 리액트의 것과 같다고 말할 수 없다.

# 문제 제기

`<NameField>`는 사용자가 이름을 입력할 수 있는 컴포넌트다.
input 앨리먼트를 반환한다.

이 앨리먼트는 name 변수에 할당한 문자열을 value로 갖고 있다.
사용자가 입력 값을 변경하면 handleChange 함수가 동작하면서 이벤트를 받는다.

```jsx
function NameField {
  const name = "정환";

  const handleChange = event => {
    // 변경한 값을 어디에 저장하지?
  }

  return <input value={name} onChange={handleChange} />;
}
```

이런 모양이다.

![NameField의 UI](NameField1.png)

인풋 필드에 값을 바인딩하려면 handleChange 함수에서 value 값을 바꿔 주어야 한다.
하지만 name은 단순히 함수 본문 선언한 상수다.
함수를 실행할 때는 문자열 값이기 때문에 다시 설정할 수 없다.

name이 상수라서 그런걸까? let으로 선언하면 어떻게 다를까?

```jsx
function NameField {
  let name = "정환";

  const handleChange = event => {
    name = event.target.value
  }

  return <input value={name} onChange={handleChange} />;
}
```

함수가 호출되어 반환한 앨리먼트에는 "정환" 문자열이 담겨 있다.
사용자가 필드에 입력하면 handleChange 함수가 움직이고 name 값을 바꾼다.

```js
name = "정환1"
```

하지만 거기까지다. 함수 컴포넌트가 다시 호출되기 전까지 돔에 보이는 것은 처음 반환한 앨리먼트 값이다.

```jsx
<input value="정환">
```

만약 어디선가 함수 컴포넌트를 다시 호출한다고 해서 문제가 해결되지는 않을 것 같다.
다시 호출하더라고 함수 상단에 표현식 때문에 value는 여전히 "정환"이기 때문이다.

```js
let name = "정환"
```

# 두 가지 문제

NameField가 사용자 입력을 받으려면 두 가지 숙제를 풀어야 한다.

첫째, 입력값을 **어딘가에 저장해야** 한다.

사용자의 입력에 따라 변하기 때문에 이 것을 "상태(state)"라고 부르자.
클래스 컴포넌트라면 this.state 라는 멤버 변수에 상태를 저장하고 조회하면 된다.
함수 컴포넌트에서는 상태가 없다는 것이 문제다. 함수 컴포넌트 외부 어딘가에 저장할 만한 곳을 마련해야 한다.

변하는 상태를 가지고 있다 하더라도 남은 문제가 있다.
상태 변화를 감지하고 컴포넌트를 다시 그려야 하는데 한 번 호출한 함수를 다시 호출할 방법이 없다.

둘째, 상태가 바뀌면 **함수를 다시 호출해야** 한다.

리액트의 [useState]()를 사용하면 안다.
함수 컴포넌트가 상태에 따라 반응한다.
상태를 가질 수 있고 이 값이 변하면 함수를 다시 호출한다.

컴포넌트 안에서 useState를 사용했을 뿐인데 이런 효과가 나온다면 이것이 바로 리액트의 역할(?)이 아닐까 가늠해 볼 수 있다.

코드를 보면 알수 있지 않을까 싶어 시도해 봤는데 함수 정의 부분을 못찼았다.

> 만들면서 상상해 보자!

비슷한 기능을 직접 구현해 보면 구조를 추측할 수 있지 않을까?
함수형 컴포넌트가 상태를 구독하고 리액티브하게 반응할 수 있도록 만들어 보자.

# 1차 구현

리액트에서 처리하는 이 두 가지 기능을 MyReact로 만들어 보자.

```js
function MyReact() {
  // 이름
  let firstname
  let isInitialized = false

  function useName(initilaValue = "") {
    if (!isInitialized) {
      firstname = initilaValue
      isInitialized = true
    }

    // 이름 변경
    const setFirstname = value => {
      firstname = value
    }

    return [firstname, setFirstname]
  }

  return {
    useName,
  }
}
```

마치 훅처럼 사용하기 위해서 useName 이란 함수를 정의했다.
상태의 초기 값을 받을 받았다.
훅이 처음 실행될 때만 이 값을 설정하려고 isInitialized 플래그를 활용했다.
초기값은 firstname 이란 변수에 저장 되는데 이것이 바로 상태이다.

이 상태를 변경하는 세터도 만들자.
setFirstname이란 함수인데 값을 받아서 firstname에 설정하는 역할을 한다.

마지막에는 상태값과 세터를 배열 형식으로 반환한다.

MyReact는 방금 만든 useName을 담은 객체를 반환한다.

이렇게 해서 상태를 관리하라는 첫 번째 숙제는 일단 해결했다.
두 번째 숙제를 해결할 차례다.
상태가 변하면 함수 컴포넌트를 다시 호출해서 새로운 앨리먼트가 돔에 반영되도록 해야한다.

간단히 세터 함수 본분에 다음과 같이 호출해 보자.

```js
// 클래스 컴포넌트의 forceUpdate를 흉내낸다.
// 리렌더링을 유발하는 역할이다.
const { forceUpdate } = useForceUpdate()

const setFirstname = value => {
  firstname = value

  // 상태를 변경하고 리렌더링을 유발한다.
  forceUpdate()
}
```

forceUpdate는 클래스 컴포넌트의 메서드다.
함수 컴포넌트에는 없지만 이해를 돕기위해 훅을 가져와 만들어 본 함수다.

```js
// 구현을 위해 이곳만 리액트 훅을 사용한다.
function useForceUpdate {
  const [value, setValue] = React.useState(1);

  const forceUpdate = () => setValue(value + 1);

  return {
    forceUpdate,
  };
};
```

구현 상세는 글의 방향과 무관하므로 그냥 슥 읽고 지나치자.

이렇게 해서 두 가지 숙제를 모두 해결했다.

리액트 모듈에서 api를 가져 오듯이 방금 만든 useName 훅을 사용해 보자.

```js
const { useName } = (function MyReact(){/* ... */})();

function NameField {
  // useName을 이용해 name과 setName을 얻는다.
  const [firstname, setFirstname] = useName("정환"); // firstname = "정환"

  const handleChange = event => {
    setFirstname(event.target.value) // firstname = 사용자가 인풋 필드에 입력한 값
  }

  return <input value={firstname} onChange={handleChange} />;
}
```

정의한 MyReact를 즉시 실행하고 반환한 객체에서 useName 함수를 가져왔다.
함수 컴포넌트 NameField 본문에서 이 함수를 사용한다.

초기값 "정환"을 전달하고 반환된 배열에서 상태 값과 세터를 가져와서 각 각 firstname, setFirstname 란 이름에 담당ㅆ다.

firstname은 인풋의 value로 전달하고 인풋의 이벤트 핸들러에서는 setFieldname의 인자로 입력한 값을 전달했다.
이 세터는 상태를 변경하고 나서 곧장 화면을 다시 그리도록 리액트에 요청할 것이다.
NameField는 다시 호출되는데 이때 firstname은 방금 변경한 상태값이 될 것이다.
이 값을 이용해 리액트 앨리먼트를 반환할 것이고 리액트는 이 걸 돔에 그리게 될 것이다.

![NameField가 상태를 사용할 수 있다](NameField2.png)

이제 NameField 컴포넌트는 상태를 가지게 되었다.

# 다중 상태 관리

NameField에 이름(firstname)뿐만 아니라 성(lastname)도 입력 받도록 해보자.
필드 갯수만큼 상태가 있어야 할텐데 지금의 구조로 가능할까?

먼저 MyReact 함수 본문을 범용적인 이름으로 바꿔보자.

```js
function MyReact() {
  // 상태 값
  let value

  // 상태를 사용하는 함수
  function useState(initilaValue = "") {
    const { forceUpdate } = useForceUpdate()

    if (!isInitialized) {
      value = initilaValue
      isInitialized = true
    }

    // 상태 변경
    const setValue = nextValue => {
      value = nextValue
      forceUpdate()
    }

    return [value, setValue]
  }

  return {
    useState,
  }
}
```

useState를 이용해 상태를 하나 더 추가하자.

```js
const { useState } = (function MyReact(){/* ... */})();

function NameField {
  const [firstname, setFirstname] = useState("정환"); // firstname = "정환" ?
  // lastname 상태를 추가한다
  const [lastname, setLastname] = useState("김"); // lastname = "김" ?
  // ...
  return (
    <>
      <input value={firstname}/>
      <input value={lastname}/>
    </>;
  )
}
```

어떻게 될까?

![두 필드가 같은 상태를 바라본다](NameField2_2.png)

두 필드가 같은 값이다.
useState를 두 번 호출했는데 첫번째 호출할 때 전달한 값이다.

왜 이렇게 되었을까?
원인은 MyReact에 선언한 value 변수다.
useState를 여러번 호출하더라도 항상 value에 값을 할당한다.
게다가 처음 호출되었을 경우만 초기값을 할당하기 때문에 가장 먼저 전달한 "정환"이 지금의 상태값이다.

# 2차 구현

다중 상태를 구현하려면 value 구조를 바꿔야하겠다.

```js
function MyReact() {
  // 상태 목록
  const values = []
  // 각 상태의 초기화 여부 목록
  const isInitialized = []

  // 상태 목록에서 사용할 cursor를 받는다
  function useState(cursor: number, initilaValue = "") {
    const { forceUpdate } = useForceUpdate()

    // 지정한 상태의 초기화 여부 값을 조회한다
    if (!isInitialized[cursor]) {
      // 지정한 상태의 값을 설정한다
      values[cursor] = initilaValue
      isInitialized[cursor] = true
    }

    // 지정한 상태를 조회한다
    const value = values[cursor]
    const setValue = (value: any) => {
      // 지정한 상태의 값을 변경한다
      values[cursor] = value
      forceUpdate()
    }

    return [value, setValue]
  }

  return {
    useState,
  }
}
```

value를 values 배열로 바꿨다.
useState를 호출할 때마다 이 배열의 적당한 위치에 초기값을 설정하겠다.

초기값은 처음 호출될 때 설정하는데 initialzied 플래그를 보고 판단한다.
이것도 불리언 타입에서 배열로 변경해야겠다.

이제 useState는 초기값 뿐만아니라 위치정보 cursor도 받아야 한다.
상태를 목록으로 만들었기 때문에 어느 위치에 있는 상태를 조회할 것인지 찾기위한 목적이다.

이 값은 isInitialized 배열에서 최초 호출 여부를 찾기위에서도 사용된다.

물론 세터에서 값을 세팅하기 위해서도 사용되는 값이다.

사용해 보자

```jsx
function NameField3() {
  const [firstname, setFirstname] = useState(0, "정환")
  const [lastname, setLastname] = useState(1, "감")

  const handleChangeFirstname = event => {
    setFirstname(event.target.value)
  }
  const handleChangeLastname = event => {
    setLastname(event.target.value)
  }

  return (
    <>
      <input value={firstname} onChange={handleChangeFirstname} />
      <input value={lastname} onChange={handleChangeLastname} />
    </>
  )
}
```

useState를 호출할 때 호출 순서에 맞게 cursor 값으로 0, 1을 각 각 전달했다.

![다중 상태를 사용할 수 있다](NameField3.png)

두 필드가 각 각 다른 상태를 구독한다.

# 더 단순하게

useState를 호출할때 어느 상태를 구독할지 커서를 넘기는 것은 불편하다.
실수하기 쉬운 api다.
useState를 몇번 호출하던지 커서를 관리하는 역할은 사용하는 측이 아니라 제공하는 측이다.
스스로 관리하도록 MyReact를 개선해 보자.

```js
function MyReact() {
  // 상태를 가리킨다
  let cursor = 0

  function useState() {
    // 커서를 지정한 세터를 반환한다
    const setValueAt = cursor => value => {
      values[cursor] = value
      forceUpdate()
    }

    // 커서를 지정한 세터를 만든다
    const setValue = setValueAt(cursor)

    // 커서를 1 증가한다
    cursor++

    return [value, setValue]
  }

  // 커서 초기화 함수
  function resetCursor() {
    cursor = 0
  }

  return {
    useState,
    resetCursor,
  }
}
```

cursor를 스스로 관리하도록 MyReact 함수 본문에 선언했다.

useState가 호출될 시점에는 cursor가 특정 상태를 가리키기고 있다.
이 값을 세터에 잡아 두기 위해 setValueAt 함수를 만들었다.
이것으로 특정 커서의 setValue 함수를 만든다.

그리고 나서 cursor를 올려 다음 useState 호출에서 사용하도록 준비해 둔다.

함수 컴포넌트가 호출될때 커서를 리셋하기 위해 resetCursor 함수도 제공한다.

이번에는 이렇게 사용해 보자.

```jsx
function NameField() {
  // 커서를 다시 설정한다
  resetCursor()

  const [firstname, setFirstname] = useState("정환") // cursor 0
  const [lasname, setLastname] = useState("김") // cursor 1

  // ...
}
```

좀더 리액트의 useState와 비슷해 졌다.
컴포넌트 시작부에 resetCursor를 호출하는데 MyReact의 한계다.

# 결론

주의. 구현 방법일 뿐이지. 리액트가 이렇게 구현한 것은 아님.

## 참고

- [예제 코드](https://github.com/jeonghwan-kim/2022-04-02-react-hooks)
- [eact hooks: not magic, just arrays](https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e)
