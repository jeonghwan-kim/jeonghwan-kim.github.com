---
slug: "/2024/07/11/lecture-http-part5"
date: 2024-07-11 00:01:00
title: "[HTTP] 5편. 보안"
layout: post
series: "HTTP"
---

# 13장. 브라우져 보안

- 보안: 어플리케이션의 틈을 비집고 들어서 시스템을 파괴하거나 정보를 유출
- 브라우져의 보안 정책

## 13.1 크로스 사이트 스크립팅

크로스 사이트 스크립팅(Cross-Site Scripting, XSS)

- 악의적인 스크립트를 웹 페이지에 삽입해 공격하는 기법
- 다른 보안 공격의 기점이 됨

인라인 자바스크립트를 웹 문서에 주입한 공격

- 결과: 의도치 않은 스크립트가 실행되어 어플리케이션을 망칠 수 있다.
- 예방: 세니타이즈(Sanitize)
- 라이브러리: [DOMPurify](https://github.com/levmyshkin/dom_purify)

HTML 태그를 웹 문서에 주입한 공격

- 결과: 의도치 않게 문서를 조작할 수 있다.
- 예방: 에스케이프(Escape)
- 라이브러리: [Lodash.escape](https://lodash.com/docs/4.17.15#escape)

## 13.2 세션 하이재킹

웹 어플리케이션의 로그인 기능

- 브라우져: 인증 정보를 입력 받아 서버로 전송
- 서버: 인증 유효성을 검증하고 통과하면 클라이언트를 식별할 수 있는 세션 식별자를 만들어 쿠키로 응답
- 브라우져: 이후 요청에 쿠키의 세션 식별자를 전달해 인증을 유지

다른 출처로 세션 쿠키를 유추하는 공격

- 결과: 세션 식별자가 유출되어 다른 사용자로 위장해 서버에 요청할 수 있다.
- 예방: HttpOnly 쿠키 디렉티브 설정, 자바스크립트로 쿠키 접근을 차단
- 세션 하이재킹(Session Hyjaking)

## 13.3 교차 사이트 요청 위조

공격자가 사용자를 속여서 그 사용자가 인증된 세션 내에서 무의식적으로 요청을 보내도록 유도하는 공격

- 결과: 다른 사이트에서 현재 사이트의 인증된 기능을 실행해서 데이터를 유출할 수 있다.
- 예방: SameSite 쿠키 디렉티브 설정, CSRF 토큰, CAPTCHAR
- 교차 사이트 요청 위조 (Cross-Site Request Forgery, CSRF)

## 13.4 컨텐츠 보안 정책

Content-Security-Policy 응답 헤더

- 다른 출처의 자원을 브라우져가 로딩하는 것을 제어할 수 있다.
- 서버가 응답 헤더에 정책을 실어 보내면 브라우져는 이 정책에 따라 자원을 로딩한다.

```shell
< Content-Security-Policy: default-src 'self'
```

자원 종류별 정책을 설정

- script-src: 자바스크립트 출처에 대한 정책
- style-src: 스타일 시트 출처에 대한 정책
- img-src: 이미지 출처에 대한 정책

Content-Security-Policy-Report-Only 응답 헤더

- 보안 진단만하고 로드를 차단하지는 않는다.
- 진단 결과를 서버에 리포트한다.
- 사례 탐구: 구글 사이트

CSP 뿐만 아니라 쿠키, 새니타이즈, 에스케이프 따위의 **종합적**으로 사용해서 보안 사고를 예방할 수 있다.

## 13.5 동일 출처 정책

브라우져 스스로 자원의 출처를 관리하는 정책. Same Origin Policy

- 목적: 악의적인 웹사이트로 데이터를 유출, 수정하는 것을 제한한다.
- 같은 출처의 자원만 로드할 수 있다.

교차 출처 제한 대상

- fetch 함수
- XMLHttpRequest 객체
- @font-face

교차 출처 허용 대상

- 스크립트 `<script>`
- 스타일 시트 `<lint rel="stylesheet">`
- 이미지 `<img>`
- iframe `<iframe>`
- 웹폰트

CSP와 비교

- 목적
  - SOP: 다른 출처의 자원에 접근하는 것을 제어
  - CSP: 다른 출처의 자원이 브라우져에 로드되는 것을 제어
- 특징
  - SOP: 브라우져 기본 보안 정책
  - CSP: 개발자가 명시적으로 설정하는 정책

어플리케이션 시스템 구조상 이 정책을 지키지 않아야 하는 경우

- 브라우져에서 호출하는 API 서버가 다른 도메인일 경우
- CSS에서 @font-face에 로드할 URL의 출처가 다른 경우

## 13.6 중간 정리

- 공격 기법: 크로스 사이트 스크립팅(XSS)
- 응용 공격 기법: 세션 하이재킹, 교차 사이트 요청 위조(CSRF)
- 브라우져 보안 정책: CSP, SOP
- 참고

# 14장. CORS

## 14.1 도입

용어

- **출처(Origin)**: URL의 프로토콜, 호스트, 포트
- **교차 출처 요처(Cross Origin Request)**: 다른 출처의 자원을 사용하는 요청

브라우져는 실행중이 어플리케이션의 출처와 다른 출처의 자원을 요청하면 이를 차단한다. 허용하기 위한 서버와의 약속이 바로 Cross Origin Resource Sharing, CORS.

상황 재현하기

## 14.2 단순 요청

단순요청(Simple Request)

- GET, POST, HEAD 메소드를 사용한다.
- 안전한 헤더를 사용한다.

단순 요청에서는 헤더에 출처를 실어서 판단한다.

- **Origin** 요청 헤더에 출처를 실어서 서버로 보낸다.
- **Access-Control-Allow-Origin** 응답 헤더에 허용할 출처를 실어서 브라우져로 보낸다.

```
> Origin: http://localhost:3000
< Access-Control-Allow-Origin: http://localhost:3000
```

## 14.3 헤더

안전한 헤더(CORS_safelisted request-header)

- Accept
- Accept-Language
- Content-Language
- Content-Type

브라우져가 교차 출처 요청 시 이 외의 헤더를 사용하려면 서버에게 확인해야 한다.

- **Access-Control-Allow-Headers** 요청, 응답 헤더로 허용할 헤더 목록을 확인한다.
- 서버가 허용하지 않은 헤더를 사용하면 브라우져는 CORS 오류를 던진다.

```
> Access-Control-Allow-Headers: X-Foo
< Access-Control-Allow-Headers: X-Foo
```

## 14.4 사전 요청

교차 출처 요청에 PUT, PATCH, DELETE 메소드를 사용하면 브라우져는 사전요청(Preflighted Reuqst) 을 만든다.

- 브라우져: OPTIONS 메소드를 사용해 **Access-Control-Request-Method** 헤더에 사용할 메서드를 실는다.
- 서버: **Access-Control-Allow-Methods** 헤더에 허용할 메소드를 실는다.
- 브라우저는 이 헤더를 확인하고 이어서 본 요청을 보낸다.

```
> Access-Control-Request-Method: PUT
< Access-Control-Allow-Methods: PUT, PATCH, DELETE
```

## 14.5 캐시

사전 요청을 캐시할 수 있다.

- 서버: **Access-Control-Max-Age** 헤더에 캐시 기간(초)를 설정한다.
- 브라우져: 캐시로 사전 요청을 생략하고 본 요청을 보낸다.

## 14.6 사례

CORS를 사용하는 요청

- fetch(), XHR
- 웹 폰트
- (...)

현업에서 겪은 사례 소개

## 14.7 중간 정리

- 용어: 출처, 교차 출처 요청, 교차 출처 자원 공유
- 단순 요청: Origin, Access-Control-Allow-Origin
- 안전하지 않은 헤더를 사용한 요청: Access-Control-Allow-Headers
- 사전 요청: Access-Control-Request-Method, Access-Control-Allow-Methods
- 사전 요청 캐시: Access-Control-Max-Age
- 사례

# 15장. HTTPS

## 15.1 해시

데이터를 고정된 길이의 고유한 문자로 변경하는 함수를 해시라고 부른다. 해시 만든 결과물은 '요약하다'라는 의미로 다이제스트(Digest) 혹은 해시 값이라고 한다.

해시값은 다음 특징이 있다.

- **고정 길이**: 입력값 갈이와 무관하게 고정된 길이의 해시 값을 만든다.
- **고유성**: 서로 다른 데이터는 다른 해시값을 가진다.
- **변경 불가**: 데이터가 조금만 바뀌어도 결과가 크게 달라진다.
- **단방향**: 해시 값으로부터 입력 데이터를 복원할 수 없다.

## 15.2 암호화

해시로 변경한 값은 원래 값으로 복구할 수 없다. 입력 데이터를 변경하고 다시 복구하는 것을 암호화라고 한다.

암호화는 다음 특징이 있다.

- **암호화**: 데이터를 암호화해서 읽지 못한다.
- **복호화**: 암호화된 데이터를 복호화해서 읽을 수 있다.
- **키**: 암호화, 복화화할 때 키를 사용한다.

대표적인 알고리즘: AES(Advanced Encryption Standard)

- **대칭키 암호화**: 암호화와 복호화에 같은 키를 사용한다.
- **속도**: (비대칭키 암호화에 비해) 빠르다.
- **용도**: 대량의 데이터를 빠르게 암/복호화하는데 사용한다. 파일 암호화, 데이터베이스 암호화, 통신 데이터 암호화

## 15.3 비칭키 암호

대칭키 암호는 키를 서로 알아야한다. 키 배포 및 관리가 어렵고 유출시 위험이 있다. 이를 보안하기 위한 방법으로 비대칭키 암호방식을 함께 사용한다.

비대칭키 암호화는 다음 특징이 있다.

- **키 구본**: 암호화 키와 복호화 키를 구분해서 사용한다.
- **공개키**: 상대에게 암호용 키를 공개하는데 이를 공개키라고 한다. 상대는 암호키로 암호화해 전송한다.
- **개인키**: 암호화된 데이터를 복호화키로 해독한다. 나만 알고 있다고해서 개인키라고 부른다.
- **서명**: 개인키는 일종의 신분 확인 용도로 사용한다.

대표적인 알고리즘: RSA(Rivest-Shamir-Adleman)

- **비대칭키 암호화**: 암호화와 복호화에 다른 키를 사용한다.
- **속도**: (대칭키 암호화에 비해) 느리다.
- **보안**: 더 높은 보안성
- **용도**: 인터넷 상의 신분을 확인하는 용도로 사용한다. 디지털 서명, 디지털 인증서

## 15.4 디지털 서명

비대칭키 암호화를 활용해 디지털 신분을 증명하는 기술로 사용할 수 있다. 개인만 알고있는 개인키를 사용해 신분을 증명한다.

디지털 서명의 원리:

1. **Digest 생성**: 신분을 증명할 A가 평문 데이터의 해시 값을 생성한다. 일종의 신분 내용의 요약(Digest)
2. **서명 생성**: 이 값을 개인키로 복화화 함수에 전달한다. 이것을 <서명>으로 사용한다.
3. **전달**: B에게 평문 데이터와 서명을 전달한다.
4. **검증** B는 평문 데이터의 해시 값을 생성한다. A와 같은 방법으로 Digest 생성.
5. 이 값을 공개키로 암호화 함수에 전달한다. 이것이 서명과 같은지 판단해 A의 신분을 확인한다.

## 15.5 디지털 인증서

디지털 서명을 이용하면 인증된 문서를 만들 수 있다. 신뢰할 수 있는 기관으로부터 인터넷상의 사용자 신원을 보증하는 문서를 **디지털 인증서**라고 한다.

인증서 내용:

- 대상자 이름(서버, 조직 등)
- 유효 기간
- 발급자
- 디지털 서명
- 서명 알고리즘
- 공개키

디지털 인증서에 대한 표준은 없다. 대부분의 인증서가 X.509 형식을 따른다.

## 15.6 TLS

TCP계층과 어플리케이션 계층 사이에 보안 레이어를 TLS(Transport Layer Security) 라고 한다.

브라우져와 서버가 TLS를 이용해 HTTP 통신을 보호하는 방법은 다음과 같다.

**1. 핸드 쉐이크**

- ClientHello: 지원하는 암호화 알고리즘과 TLS 버전 제안
- ServerHello: 사용할 암호화 알고리즘과 TLS 버전 선택
- 서버가 디지털 인증서를 브라우져에게 전달
- 브라우져가 디지털 인증서를 확인
  - 날짜 검사
  - 서명자 신뢰도 검사
  - 서명 검사
  - 사이트 신원 검사
- 브라우져가 세션 키를 생성

**2. 데이터 전송**

- 브라우져와 서버는 세션키로 암호화 통신

## 15.7 HTTPS 서버 제작

- 로컬 인증서 제작
- https 노드 모듈 사용

## 15.8 중간 정리

- 해시
- 암호화 (대칭키 암호화)
- 비대칭키 암호화
- 디지털 서명
- 디지털 인증서
- TLS
- HTTPS 서버 제작
- 참고
  - HTTP 완벽 가이드 > 14장 보안 | 인사이트
  - 리얼월드 HTTP | 한빛미디어
