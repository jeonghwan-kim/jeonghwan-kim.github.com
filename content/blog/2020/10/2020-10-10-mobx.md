---
title: "상태관리 라이브러리 mobx"
layout: post
category: dev
tags: [mobx]
---

일 년 정도 리액트, 리덕스 조합으로 사용해 봤다.
뷰(vue)나 모빅스(mobx)에 비해 러닝커브가 있다고 했지만 반복하고 시간이 지나니 익숙해 지더라.

그러던 중 신규 프로젝트에 상태관리 라이브러리로 모빅스를 사용해 보자는 의견이 팀에서 나왔고 비교적 단순해 보였다.
결과를 보자면 역시 단순하다.
다음 프로젝트에서도 모빅스를 사용하고 있다.
기본 개념을 정리해 두도록 하자.

# 기본 개념

세 가지 용어가 등장한다.

- 상태(state)
- 데리베이션(derivation)
- 액션(action)

## 상태

상태는 어플리케이션의 상태를 담고 있는 값이다.
예를 들어 로그인 여부를 담고 있는 불리언 값이거나 할 일 정보를 담고 있는 객체 따위가 될 수 있다.

```js
const isLogin = observer(true)
const todos = observer({
  title: "todo 1",
  completed: false,
})
```

## 데리베이션

데리베이션은 상태의 변화에 반응하는 것을 말한다.
데이베이션을 번역하기가 마땅치 않아서 영어 단어 그대로 사용했는데 사전에 보면 "유도", "파생" 이라는 의미를 가진다.
상태의 변화에 따라 반응하는 것은 UI나 데이터 그리고 백엔드와의 연동이 있다.

데리베이션은 두 가지로 분류할 수 있다.

- 계산된 값(computed values)
- 리액션(reactions)

계산된 값은 순수 함수를 사용하는데 가령 투두 상태를 변경할 때마다 완료한 두투 갯수가 반응하는 것이 계산된 값이다.

```js
const completedTodos = computed(() => {
  return todos.filter(todo => todo.completed)
})
```

순수 함수를 사용하는 계산된 값에 비해 리액션은 순수하지 않는 즉 사이드 이펙트(side effiect) 형태이다.
투두 상태를 변경할 때마다 완료한 투두 갯수가 변경되고 이어서 버튼에 변경된 투두 갯수를 그리기 위에 DOM을 조착하는 행위다.

```js
const TodoList = () => {
  return completedTodos.map(todo => <TodoItem todo={todo} />)
}
```

## 액션

데리베이션을 유도하기 위해서는 상태를 변경해야 하는데 이 역할을 하는 것을 액션이라고 한다.
상태를 변경하는 액션은 뭐 거창한 것이 아니라 단순히 상태에 값을 할당하는 방식으로 단순하다.
물론 엄격 모드(strict mode)에서는 action 에서만 상태를 변경하도록 강제하지만 실제 프로젝트할 때는 상태 변수에 값을 할당하는 것 만으로 잘 동작했다.
이것이 리덕스에 비해 모빅스의 장점이라고 생각한다.

```js
todos[0].complted = true
```

## 샘플코드

```

```

# 몇 가지 원칙

위 세가지 개념은 다음과 같은 순서로 동작한다.
액션이 상태를 변경한다. 그럼 상태에 따라 이를 감시하고 있는 값이 변하고 사이드 이펙트가 발생한다.

![액션 - 스테이트 - 뷰 (출처: https://mobx.js.org/the-gist-of-mobx.html)](./images/action-state-view.png)

## Derivation은 원자적

상태를 변경하는 채널은 여러개 일 수 있다.
한 번에 여러 채널에서 상태를 변경하면 이에 따라 데리베이션이 여러번 일어나서 값의 변화를 화면에 보여주게 되지 않나 염려할지 모르겠다.
하지만 Mobx는 값을 원자적으로 변경하기 때문에 여러번 요청이 오더라도 단 한 번만 반응한다.

> All Derivations are updated automatically and atomically when the state changes. As a result it is never possible to observe intermediate values.

리덕스 사가를 사용하면 takeLates() 같은 함수를 써서 여러번 요청이 올때 마지막 한번만 잡는 방식을 썼는데 이걸 모빅는 기본으로 해 주는 것 같다.

## Derivation은 동기적

액션에서 상태를 변경하고 나서 다시 그 상태값을 조회할 때 이게 변경 완료된 것인지 의문일 수 있다.

하지만 걱정할 것 없다. 모든 데리베이션은 기본적으로 동기적으로 갱신된다. 따라서 상태를 변경하는 액션은 안전하게 변경된 값에 접근 할수 있다.

> All Derivations are updated synchronously by default.
> This means that, for example, actions can safely inspect a computed value directly after altering the state.

## 계산된 값은 느리게

> Computed values are updated lazily.
> Any computed value that is not actively in use will not be updated until it is needed for a side effect (I/O).
> If a view is no longer in use it will be garbage collected automatically.

계산된 값은 느리게 갱신된다. 이게 무슨 의미 일까? 모든 상태 변화에 따라 계산된 값이 동작하지는 않는다. 이것이 사용되어야만 동작한다. 다음 코드를 보자

개념에서도 언급했지만 계산된 값은 순수함수로 만들어야한다. 그렇기 때문에 상태를 변경해서는 않된다. 실수로 상태를 변경하게 되면 이런 결과가 나온다.

# 리액트에서 사용하기

리액트를 사용한 프로젝트에서 모빅스를 사용했는데 이때 필요한 것이 react-mobx 패키지다.
이 녀석은 리액트 컴포넌트가 모빅스 상태에 반응하도록 만들어 주는 HOC이다.
마치 리덕스 상태를 컴포넌트 프롭스로 전달해서 컴포넌트가 리덕스 상태에 따라 렌더 사이클을 돌리도록 하는것과 유사한 목적이다.

// TODO 샘플코드

```jsx
observer(() => //)

@observer
class Foo extends React.Component {}

이렇게 컴포넌트를 observer() 로 감싸야만 모빅스 상태에 접근할 수 있다. 이 컴포넌트는 상태에따라 다시 그리기 때문에 데리베이션이라 할수 있다. 또한 상태 값을 변경할 수 있기 때문에 액션이기도 하다.

// TODO 샘플 코드

class State {
@observable isLogin: boolean;

}
const state = new State()

const Foo = () => {
const handleClick = () => state.isLogin = !state.isLogin;

return <button onClick={handleClick}>{state.isLogin ? “Logout” : “Login”}</button>
}
observe(Foo)
```

# 정리

## redux와 차이

상태를 변경하려면 액션을 던저야함. 그런게 없음. 옵져버블을 변경하면 나머지는 모빅스가 처리. 흑마법이 좋더라. 백마법 아닌가?
거대한 단일 스토어가 아니라, 필요한 만큼 스토어를 만들면 된다.

그래서 결론을 어떻게 작성해야 할까이나? 내일 작성해야되는디...

참고

- [post-mobx-timer](https://codesandbox.io/s/post-mobx-timer-bqi7j?file=/src/index.js)
- [post-mobx-timer-react](https://codesandbox.io/s/post-mobx-timer-react-mx9fm?file=/src/App.tsx)
