---
title: "Passport"
layout: post
category: dev
tags: [nodejs, authentication]
---

TBD
직접 만들면서 패스포트의 원리를 이해해 보자 


# 준비

웹 어플리케이션에서 인증을 구현하기 위한 방법으로 세션과 쿠키를 많이 사용한다.
서버와 브라우져 역할을 간단히 정리하면...
- 서버는 접속한 브라우져를 식별하기 위해 세션 저장소에 정보를 저장하고 식별자 세션 아이디를 브라우져에게 쿠키로 전달한다.
- 브라우져는 받은 쿠키를 저장하고 있다가 다음 요청부터는 세션 아이디를 헤더에 담아 서버로 전송한다.
- 서버는 이 값을 가지고 이전에 접속한 브라우져임을 식별할 수 있다. 

## 세션 설치 

익스프레스에서 세션을 사용하기 위해 [express-session](https://www.npmjs.com/package/express-session) 미들웨어를 사용하겠다.

```ts
// src/index.ts

import session from 'express-session';

app.use(session({
  name: 'mysession', // 쿠키에 저장될 세션키 이름
  secret: 'qwer1234', // 세션 암호화를 위한 시크릿 
  resave: true, // 옵션 참고
  saveUninitialize: true, // 옵션 참고 
}))
```

설치 한 뒤 세션 데이터를 들여다 보기 위해 GET /debug라는 엔드포인트를 하나 만들었다.

```ts
// src/index.ts

app.get('/debug', (req, res) => {
  res.json({
    'req.session': req.session, // 세션 데이터
    'req.user': req.user, // 유저 데이터(뒷 부분에서 설명)
    'req._passport': req._passport, // 패스포트 데이터(뒷 부분에서 설명)
  })
});
```

브라우져로 /debug 에 접속하면 세션 정보를 확인 할 수 있다.

```ts
{
  "req.session": {
    "cookie": {
      "originalMaxAge": null,
      "expires": null,
      "httpOnly": true,
      "path": "/"
    }
  }
}
```

쿠키(cookie) 데이터가 요청한 클라이언트로 전송될 것이다.


## 로그인 폼

먼저 로그인 폼을 만드는 것 부터 시작해 보자.

```html
<!-- public/login.html -->

<form action="/login" method="post">
  <input name="username" placeholder="user1" />
  <input name="password" placeholder="pass01" />
  <button type="submit">로그인</button>
</form>
```

사용자로부터 username과 password를 입력 받고 폼을 제출하면 브라우져는 POST /login으로 데이터를 전송할 것이다.

이 파일을 제공할 엔드포인트 GET /login을 라우터에 추가한다.

```ts
// src/index.ts

app.get('/login', (req, res) => {
  // login.html 경로
  const loginTemplate = path.resolve(__dirname, '../public/login.html'); 

  // html 파일을 제공한다
  res.sendFile(loginTemplate)
})
```

이제 브라우져로 localhost:3000/login에 접속하면 로그인 화면을 볼 수 있다.

![login form](/assets/imgs/2020/06/20/login-form.jpg)


## 로그인 폼 처리 

폼을 입력하고 제출하면 이를 처리할 POST /login 엔드포인트를 서버에 추가하자.

```ts
// src/index.ts

app.post('/login', (req, res, next) => {
  // TODO: credentials(username, password) 검증 
})
```

이 컨트롤러에 로그인 기능을 시작하면 된다.

# mypassport: 직접 만들기 

## 로그인 기능

passport를 직접 사용하기 전에 직접 로그인 기능을 만들어 보면서 동작 원리를 이해해 보자.
mypassport라는 모듈을 만들어서 로그인 역할을 하도록 하겠다.

```ts
// src/lib/mypassport.ts

class MyPassport {
  // 세션에 저장할 인증정보 키 
  readonly key = 'userId';

  // 로그인
  authenticate() {
    // 미들웨어 함수를 반환한다 
    return (req, res, next) => {
      try {
        // username, password로 디비에서 유저를 찾는다
        const { username, password } = req.body;
        const user = users.filter(u => u.identify(username, password))[0];

        // 유저가 없으면 401 Unauthorized 를 응답한다 
        if (!user) return res.sendStatus(401);

        // 유저를 찾으면 세션에 userId를 저장한다
        req.session[this.key] = user.id;
        
        // 다음 미들웨어를 실행한다 
        next()
      } catch (err) {
        // 로그인 과정중 에러가 발생하면 에러 미들웨어를 실행한다
        return next(err);
      }

    }
  }
}

// 싱글톤
export default new MyPassword();
```

클래스 멤버로 key를 두었다. 
세션에 로그인 정보를 저장할 때 사용할 속성 이름이다.

authenticate() 메소드가 실제로 로그인을 수행하는 역할을 하는데 미들웨어 함수를 반환하여 익스프레스 어플리케이션과 호환성을 맞췄다.

요청한 username과 password로 데이터베이스에서 일치하는 유저를 찾는다.

유저를 찾으면 세션에 인증 정보를 저장한다. 유저 아이디만 저장해서 최소한의 데이터만 세션에 유지하도록 했다.

만약 이 일련의 과정중에 예외가 발생한다면(가령 디비 연결 실패나 세션 초기화 실패 등) 에러 미들웨어에게 맞기도록 했다.

마지막으로 new 키워드로 객체를 만들었고 곧장 모듈로 노출시켜서 싱글톤으로 만들었다.

## 로그인 컨트롤러 

MyPassword 모듈로 로그인 기능을 만들었으니 로그인 엔드포인트에 이를 적용해 보자.

```ts
app.post('/login', mypassport.authenticate(), (req: Request, res: Response) => {
  res.send('로그인 성공')
})
```

authenticate() 메소드가 반환한 미들웨어를 컨트롤러 함수 직전에 전달함으로써 인증과정을 먼저 수행할 수 잇다.
인증에 성공한 뒤 컨트롤러 로직이 수행되는 것을 보장할 수 있다.

한편 인증에 실패하면 mypassport에서 401을 브라우져에 반환할 것이다.
예외가 발생하면 이후 오류 미들웨어에서 처리할 것이다.

로그인 후 세션 상태를 보면 userId 키에 사용자 아이디가 있다.

```ts
{
  "req.session": {

    // userId가 추가 되었다
    "userId": 1 
  }
}
```

세션에 저장되어 있기 때문에 유효기간 내 모든 요청에서 이 데이터가 지속될 것이다. 

## 세션에서 로그인 상태 복구 

익스프레스 프레임워크는 요청 정보를 모두 Response 객체에서 관리하고 있다. 
인증된 유저일 경우에는 req.user에 유저 정보를 넣어주면 좋겠다.
컨트롤러 로직에서 요청한 유저 정보에 일관적으로 접근할 수 있기 때문이다.

그러면, 모든 요청 앞단에서 세션의 로그인 정보를 req.user로 복구하는 기능을 만들어 보자.

```ts
class MyPassport {
  session() {
    return (req, res, next) => {
      // 세션에 로그인 정보가 있으면 
      if (req.session[this.key]) {
        // 유저 식별자로 디비에서 유저를 찾기 시도 
        const user = users.filter(u => u.equal(req.session![this.key]))[0];

        // 유저를 찾으면 req.user 에 유저 객체 할당
        if (user) req.user = user;
      }

      // 다음 미들웨어 실행
      next();
    }
  }
}
```

MyPassport 클래스에 seeesion() 메소드는 세션에서 로그인 정보를 복구하는 역할을 한다.

이전 요청에서 로그인 했다면 세션에 로그인 정보가 있을 것이다. 

세션의 유저 식별자로 데이터베이스에 있는 유저를 찾는다.
유저가 있다면 이를 req.user에 할당한다.
이후 미들웨어나 컨트롤러 함수에서 req.user로 요청한 유저를 조회할 수 있도록 편의를 제공하는 것이다.

이걸 어플리케이션에 적용하는 것은 간단하다.

```ts
// 세션 활성화
app.use(session({/* ... */}))

// 세션에서 로그인 정보를 복구한다 
app.use(mypassport.session())
```

세션을 활성화 한 직후 세션에서 로그인 정보를 복구하도록 순서를 맞추어 미들웨어를 세팅했다.

로그인 후 req 객체를 보면 이처럼 유저 정보가 세팅되어 있다.

```ts
{
  "req.session": {
    "cookie": { /* ... */ },
    "userId": 1
  },
  
  // req에 user 객체가 할당되었다 
  "req.user": { 
    "id": 1,
    "username": "user1"
  }
}
```

## 접근 제한 

req.user를 통해 로그인한 유저 데이터를 조회할 수 있게 되었다.
그럼 로그인한 유저만 접근할 수 있는 페이를 만들어 보자. 
가령 /profile 페이지는 내 정보를 보는 곳이기 때문에 로그인이 필요한다. 
게스트로 접속했을 경우 예외처리를 해주어야한다.

이런 식으로 사용할 수 있겠다.

```ts
app.get('/profile', (req, res, next) => {
  if (!req.user) return res.sendStatus(403);
  
  // req.user 
})
```

따로 미들웨어를 만들어 사용하면 더 편하다.

```ts
const isAuthenticated = () => (req, res, next) => {
  if (!req.user) return res.sendStatus(403);
  
  next()
}

app.get('/profile', isAuthenticated(), (req, res, next) => {
  res.json(req.user)
})
```

## 로그아웃 

간단히 세션에서 로그인 정보를 삭제하면 그만이다.

```ts
app.post('/logout', (req, res, next) => {
  // 세션에서 로그인 정보를 삭제한다.
  req.logout();
})
```

req.logout() 메소드를 추가하기 위한 MyPassport 클래스 메소드를 만들어 보자.

```ts
class MyPassport {
  // 초기화 메소드 
  initialize() {
    // 미들웨어를 반환
    return (req, res, next) => {
      // 로그아웃 메소드를 req 객체에 추가한다 
      req.logout = () => {
        // 세션에 저장된 로그인 데이터를 제거 
        delete req.session[this.key]
      }

      // 다음 미들웨어를 수행
      next()
    }
  }
}
```

MyPassport 의 초기화 작업을 하는 이 메소든는 미들웨어를 반환한다.
이 미들웽는 req 객체에 로그아웃 함수를 추가한다.

```ts
// mypassport 초기화
app.use(mypassport.initialize())

// 세션에서 로그인 상태 복구 
app.use(mypassport.session())
```

이렇게 앞단 미들웨어에서 req.logout 메소드를 추가해 놓으면 이후 컨트롤러에서 로그아웃 메소드를 사용할 수 잇다.


```ts
app.get('/logout', (req, res, next) => {
  // 로그아웃 
  req.logout()

  res.send('로그아웃 성공')
})
```

로그아웃 이후 요청에서 세션 상태를 보면 모두 삭제되었다. 

```ts
{
  "req.session": {
    "cookie": {/* ... */}
  }
}
```

# passport롤 대체 

지금까지 만들었던 mypassport 짚어 치우고 직접 passport로 대체해 보자.

초기화 작업과 세션에서 로그인 정보를 복구하는 코드를 대체한다.

```ts
import passport from 'passport'

// 초기화
// app.use(mypassport.initialize())
app.use(passport.initialize())

// 세션에서 로그인 정보 복구 
// app.use(mypassport.session())
app.use(passport.session())
```

passport는 정보를 req._passport 에 저장하는데 이걸 보기위해 debug 코드에 추가하자.

```ts
app.get('/debug', (req, res)=> {
  res.json({
    'req.session': req.session, 
    'req.user': req.user,

    // passport 정보를 들여다 보자 
    'req._passport': req._passport, 
  })
})
```

```ts
{
  "req.session": {
    "cookie": {/* ... */}
  },

  // passport 데이터가 추가 되었다. 
  "req._passport": { 
    "instance": {
      "_key": "passport",
      "_strategies": { // 전략?
        "session": {
          "name": "session"
        }
      },
      "_serializers": [],
      "_deserializers": [],
      "_infoTransformers": [],
      "_framework": {},
      "_userProperty": "user",
      "_sm": {
        "_key": "passport"
      },
      "strategies": {}
    }
  }
}
```

인증 관련한 몇가지 정보가 있다. 이 중에 세 가지만 짚어 보자.

## 전략(strategies)

패스포트는 유저네일/비밀번호의 기본 인증 뿐만 아니라 페북, 트위터 소셜 인증도 할 수 있다.
공통의 인증 로직은 passport가 담당하고 구체적인 방법은 전략이라는 이름으로 사용한다.

- 유저네임/비밀번호 인증은 passport-local 
- 페북/트위터는 passport-facebook, passport-twitter
- jwt 방식은 passport-jwt

라는 전략을 사용한다. 전략 패턴이다.

이러한 패스포트 전략을 npm 패키지로 얻을 수 있는데 전체 목록은 [여기](http://www.passportjs.org/packages/)서 확인할 수 있다.

로컬 전략을 사용해 보자.


```ts
// lib/passport.ts

import { Strategy } from 'passport-local';

passport.use(new Strategy({session: true}, (username, password, done) => {
  try {
    const user = users.filter(u => u.identify(username, password))[0];
    done(null, user ? user : false)
  } catch (err) {
    done(err)
  }
}))

```

passport.use() 함수로 전략을 등록하는데 이렇게 하면 _strategies에 등록한 전략이 보인다.

```ts
{
  "req._passport": {
    "instance": {
      "_strategies": {
        "session": {
          "name": "session"
        },
        
        // 로컬 전략 
        "local": { 
          "_usernameField": "username",
          "_passwordField": "password",
          "name": "local"
        }
      }
    }
  }
}
```

## serializeUser/deserializeUser

passport는 세션에 최소한의 인증 정보만 저장한다. 
로그인 한 뒤 세션에 데이터를 저장할때 어떤 정보를 저장할지를 결정하는 함수가 serizliseUser이다.

반대로 세션에 정장한 이데이터로 로그인한 유저 정보를 복구하는데 이걸 결정하는 함수가 deserializeUser다. 


```ts
passport.serializeUser((user: User, cb) => {
  cb(null, user.id)
})

passport.deserializeUser((userId: number, cb) => {
  const user = users.filter(u => u.id === userId)[0];
  cb(null, user)
})
```

여기까지 설정하면 passport로 대체하는 작업을 마쳤다. 

로그인 한 뒤 상태를 보면 다음과 같다.

```ts
{
  "req.session": {
    "cookies": {/* ... */}

    // serializeUser에 등록한 함수가 동작
    "passport": { 
      "user": 1 
    }
  },

  // deserialzieUser에 등록한 함수가 동작
  "req.user": { 
    "id": 1,
    "username": "user1"
  }
}
```

# 정리 

참고
- 소스코드: [https://github.com/jeonghwan-kim/post_passport](https://github.com/jeonghwan-kim/post_passport)
