---
title: "인터페이스만 사용하다가 클래스를 다시 보았다"
layout: post
category: dev
tags: TypeScript
---


타입스크립트의 타입 시스템은 무척 매력적이었다.
함수 전달 인자의 타입을 강제화 할 수 있다는 점에서 안전한 코드를 만드는데 적잖은 도움을 받고 있다.

타입은 스트링, 정수 따위의 원시 타입 뿐만이 아니다.
하나 이상의 원시 타입으로 구성된 합성 타입을 정의할 수도 있는데 "인터페이스"를 주로 이용한다.

```ts
interface User {
  name: string,
  email: string,
}
```

User 타입을 정의할때 interface 키워드로 만들수 있다. 
이걸 인자로 사용하면서 함수간의 타입 에러를 대부분 예방할수 있기 때문에 안전하게 코딩할 수 있다.

# 인터페이스 활용 

인터페이스만 맞춘다면 어떠한 함수라도 안전하게 만들 수 있다.
새로운 유저 객체를 만든다던지, 

```ts
const user: User = {
  name: '',
  emila: ''
}
```

폼으로 값을 입력받은 유저 데이터를 검증한다던지,

```ts
function validateUser(user: User): boolean;
```

유저 객체를 xhr 호출 페이로드로 사용한다던지 말이다.

```ts
function saveUser(user: User): Promise<User>
```

각각의 로직에 유저 인터페이스만 맞추면 함수는 예상하는 대로 동작한다.

하지만 어느 순간부터는 인터페이스를 맞췄음에도 불구하고 코드가 잘 눈에 들어오지 않기 시작했다. 

## 원인이 뭘까?

리액트 + 리덕스 조합의 프로젝트에서 타입스크립트를 시작했다.
문서를 읽고 샘플 코드를 공부한뒤 이런 폴더 구조를 만들었다.

```
apis // xhr
models // 데이터 모델, 보통 인페이스만 사용
actions // 액션타입, 액션 생성자
reducers // 데이터 변환 
sagas // 비동기 처리
selectors // 데이터 셀렉터
store // 스토
utils / 
container
components
pages
routers
```

리덕스 구조에 맞게 각 역할자들을 잘게 나눠 놓은 것이 처음엔 역할을 잘 분리하니깐 좋다고 생각했다.
역할의 범위까지만 생각하고 코딩하면 된다고 여겼기 때문이다.

하지만 페이지 하나를 만들라 치면 각 역할자들을 모두 건드려야하는데 이게 여간 귀찮은 일이 아니다.
페이지에서 불러올 api 호출하려면 액션 만들고, 스토어에 저장하기위헤 리듀서만들고, 비동기 로직 처리하려고 액션을 만든다.
화면에 그리기 위해 스토어에서 데이터 가져오려면 컨테이너랑 셀렉터 건드려야한다.
컴포넌트 안에 폼이라도 있으면 폼 검증하려면 컴포넌트 메소드나 분류하기 애매하면 유틸리티로 빼버렸다. 

각 역할자들 사이에서는 인터페이스로 약속하고 개발하면 된다고 생각했지만 생각처럼 잘 되지 않았다.
이게 점점 복잡도가 증가하고 결국엔 뭐가 어디 있는지, 중복된건 없는지 관리하기가 힘들었다.

# 클래스를 써야할까?

최근 팀에서 함께 작성하는 코드를 보면서 클래스 활용에 대해 유심히 보고 있다.
철저하게 리덕스 역할자들을 분리해서 작성했던 이전 관례와 다르게 클래스 위주로 코드 개발해 나가는 것이 색달랐다.

인터페이스는 타입만 지정할 뿐이지 이걸 가지고 함수를 구현하는 것이 무적 자유로웠다. 
좀 애매하게 들릴지 모르겠지만, 인터페이스 타입의 데이터와 별개로 함수는 여기저기 자유롭게 정의할수 있다는 것이다.

반며 클래스는 고유의 값을 가지고 있고 이 값을 처리하는 고유의 메소드를 가진다.
함수가 여기저기 흩어져있는 이전 방식과는 달리 고유의 값과 관련된 함수를 한곳에서 관리할수 있어서 좀더 생각하는게 단순해 졌다.

## 데이터 초기화가 필요한 경우 

인터페이스로 객체 값을 생성하는 할때는 매번 초기값을 설정해 주어야한다.

```ts
const user1: User = {
  name: '',
  emila: ''
}
```
초기값을 설정하는 녀석에 따라 이 값은 달라지 수 있다. 
이렇게 되면 User 타입의 초기값은 정의할때마다 달라지기 때문에 관리하기가 수월치 않았다.

반면 클래스는 생성자 함수가 이 역할을 하도록 수렴시킨다.

```ts
class User {
  user: string;
  email: string;

  constructor() {
    this.user: '',
    this.email: ''
  }
}
```

객체를 생성하는 즉시 일관된 초기값을 얻을 수 있다.

```ts
const user: User = new User() // {user: "", email: ""}
```

xhr 응답으로 온 유저 데이터를 User 타입으로 변경해야하는 경우도 있을 것이다.
어떤 데이터가 오더라도 생성자 함수에서 초기값을 보장할 수 있다.

```ts
class User {
  user: string;
  email: string;

  constructor(row: any = {}) {
    this.user: row.user || '',
    this.email: row.email || ''
  }
}
```

서버에서 온 데이터라면 이 값을 전달해서 User 객체로 변환할 수 있다.

```ts
const user: User = new User({user: 'alice'})  // {user: "alice, email: ""}
```

email이 없지만 생성자 함수에 의해서 빈 문자열로 초기화 된다.


## 데이터와 관련한 함수가 늘어날 경우 

클래스의 장점은 관심사가 비슷한 함수를 메소드로 모을수 있다는 점인것 같다.
데이터와 행동을 추상화해놓은 클래스 관점으로 이걸 가져와 보자. 

```ts
class User {
  validate(): boolean;
}
```

유저 입력폼을 검증한다면 유틸리티나 컴포넌트 함수로 밸리데이터를 빼지말고,
유저 데이터를 가지고 있는 User 클래스의 메소드로 정해 주면 좋다.
유저 클래스를 사용하는 어느 화면에서나 validate() 메소드를 호출하면 간단하다.
파일을 찾기도 수월하다. 유저 검증로직이 어디있더라? 라고 생각하면서 유저 클래스를 찾으면 거기 있다.

저장할때도 클래스를 사용하면 좀 좋다.

폼을 입력한 뒤 저장하려고 액션을 던지고, 사가 함수를 만들고, 결과를 리덕스에 담으려면 탭을 여러개 띄워 놓아야한다.
대신 이런헤 클래스 메소드를 만들어 보자.

```ts
class User {
  async save(): Promise<User>
}
```

유저 객체가 폼에 의해 변경되 데이터를 가지고 있기 때문에 스스로 save() 함수를 호출하면 된다.

이런식으로 데이터 중심으로 메소드를 모은 클래스를 활용하면 여기저기 흩어져있는 코드를 관심사가 비슷한 녀석끼를 묵을수 있다.
코드를 찾기 더 쉬워질 뿐만아니라 사고하는 방식도 데이터 중심이라서 좀 다르다.


# 결론 

조직을 구성할때 목적조직이나 기능조직이냐로 정할때가 있다.
비슷한 역할을 하는 리소스끼리 모와놓은 것이 기능조직이다. 프론트엔드개발팀.
하나의 결과물을 위해서 필요한 리소르를 모아놓은 것이 목적조직이다. 상품프로덕트팀.

리덕스를 이용한 구조에서는 역할별로 함수를 모아놓고 각 함수가 제역할을 하면서 인터페이스로 서로 협력하도록 해 놓은 구조다.
클래스는 하나의 프로덕트, 유저 클래스라면 유저 데이터겠지. 를 중심으로 필요한 함수를 모아 놓은 구조다. 

조직에서 이 둘을 수시로 변경한다. 정답이 없기 때문이다. 상황에 맞게 계속 변화시키는 것 같다. 

클래스와 인터페이스도 정답이 없는건 마찬가지이다. 상황에 맞게 잘 조절해야할 것같다.
여태 인터페이스만 계속사용했는데 그리고 그것이 가볍고 현명한 방식이라고 생각했는데, 이제 클래스 위주의 사고도 훈련해야할 필요가 있다고 느낀다.
